import { jest } from '@jest/globals';
import BaseAutosCommand from '../../../src/comandos/comandos/BaseAutosCommand';
import { VehicleRegistrationHandler } from '../../../src/comandos/comandos/VehicleRegistrationHandler';
import { PolicyAssignmentHandler } from '../../../src/comandos/comandos/PolicyAssignmentHandler';
import { Context } from 'telegraf';

// Mock de los handlers
jest.mock('../../../src/comandos/comandos/VehicleRegistrationHandler');
jest.mock('../../../src/comandos/comandos/PolicyAssignmentHandler');

// Mock de los teclados
jest.mock('../../../src/comandos/teclados', () => ({
    getBaseAutosKeyboard: jest.fn(() => ({
        reply_markup: {
            inline_keyboard: [
                [{ text: '📝 Registrar Auto', callback_data: 'base_autos:registrar' }],
                [{ text: '🛡️ Asegurar Auto', callback_data: 'base_autos:asegurar' }]
            ]
        }
    })),
    getMainKeyboard: jest.fn(() => ({
        reply_markup: {
            inline_keyboard: [[{ text: '🏠 Menú Principal', callback_data: 'menu_principal' }]]
        }
    }))
}));

// Mock del logger
jest.mock('../../../src/utils/logger', () => ({
    info: jest.fn(),
    error: jest.fn()
}));

describe('BaseAutosCommand', () => {
    let command: BaseAutosCommand;
    let mockBot: any;
    let mockHandler: any;
    let mockCtx: any;

    beforeEach(() => {
        // Mock del bot
        mockBot = {
            action: jest.fn(),
            command: jest.fn(),
            on: jest.fn()
        };

        // Mock del handler
        mockHandler = {
            bot: mockBot
        };

        // Mock del contexto de Telegram
        mockCtx = {
            answerCbQuery: jest.fn().mockResolvedValue(undefined),
            editMessageText: jest.fn().mockResolvedValue(undefined),
            deleteMessage: jest.fn().mockResolvedValue(undefined),
            reply: jest.fn().mockResolvedValue(undefined),
            chat: { id: 123456 },
            from: { id: 'user123' },
            match: null
        };

        // Limpiar mocks
        jest.clearAllMocks();

        // Crear instancia del comando
        command = new BaseAutosCommand(mockHandler);
    });

    describe('constructor', () => {
        test('debe inicializar correctamente', () => {
            expect(command.handler).toBe(mockHandler);
            expect(command.bot).toBe(mockBot);
        });
    });

    describe('métodos básicos', () => {
        test('getCommandName debe retornar el nombre correcto', () => {
            expect(command.getCommandName()).toBe('base_autos');
        });

        test('getDescription debe retornar la descripción correcta', () => {
            expect(command.getDescription()).toBe(
                'Base de Datos de Autos - Registro y Asignación de Pólizas'
            );
        });
    });

    describe('register', () => {
        beforeEach(() => {
            command.register();
        });

        test('debe registrar todos los handlers de acciones', () => {
            expect(mockBot.action).toHaveBeenCalledWith('accion:base_autos', expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith(
                'base_autos:registrar',
                expect.any(Function)
            );
            expect(mockBot.action).toHaveBeenCalledWith(
                'base_autos:asegurar',
                expect.any(Function)
            );
            expect(mockBot.action).toHaveBeenCalledWith('accion:volver_menu', expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith('vehiculo_cancelar', expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith('vehiculo_finalizar', expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith('poliza_cancelar', expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith(/^asignar_(.+)$/, expect.any(Function));
            expect(mockBot.action).toHaveBeenCalledWith(
                /^vehiculos_pag_(\d+)$/,
                expect.any(Function)
            );
        });

        describe('accion:base_autos', () => {
            let actionHandler: Function;

            beforeEach(() => {
                // Obtener el handler registrado
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'accion:base_autos'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock teclado
                const teclados = require('../../../src/comandos/teclados');
                teclados.getBaseAutosKeyboard.mockReturnValue({
                    reply_markup: { inline_keyboard: [] }
                });
            });

            test('debe mostrar menú de base de autos', async () => {
                await actionHandler(mockCtx);

                expect(mockCtx.editMessageText).toHaveBeenCalledWith(
                    '🚗 *Base de Datos de Autos*\n\nRegistro y gestión de vehículos para asignación de pólizas.',
                    expect.objectContaining({
                        parse_mode: 'Markdown'
                    })
                );
            });

            test('debe manejar errores', async () => {
                mockCtx.editMessageText.mockRejectedValueOnce(new Error('Error de prueba'));

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '❌ Error al mostrar el menú de Base de Autos.'
                );
            });
        });

        describe('base_autos:registrar', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'base_autos:registrar'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock del VehicleRegistrationHandler
                VehicleRegistrationHandler.tieneRegistroEnProceso = jest.fn().mockReturnValue(false);
                VehicleRegistrationHandler.iniciarRegistro = jest.fn().mockResolvedValue(undefined);
            });

            test('debe iniciar registro de vehículo', async () => {
                await actionHandler(mockCtx);

                expect(VehicleRegistrationHandler.tieneRegistroEnProceso).toHaveBeenCalledWith(
                    'user123'
                );
                expect(VehicleRegistrationHandler.iniciarRegistro).toHaveBeenCalledWith(
                    mockBot,
                    123456,
                    'user123'
                );
            });

            test('debe rechazar si ya hay registro en proceso', async () => {
                VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(true);

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '⚠️ Ya tienes un registro en proceso. Completalo o cancelalo primero.'
                );
                expect(VehicleRegistrationHandler.iniciarRegistro).not.toHaveBeenCalled();
            });

            test('debe manejar errores', async () => {
                VehicleRegistrationHandler.iniciarRegistro.mockRejectedValueOnce(
                    new Error('Error')
                );

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ Error al iniciar el registro.');
            });
        });

        describe('base_autos:asegurar', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'base_autos:asegurar'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock del PolicyAssignmentHandler
                PolicyAssignmentHandler.tieneAsignacionEnProceso = jest.fn().mockReturnValue(false);
                PolicyAssignmentHandler.mostrarVehiculosDisponibles = jest.fn().mockResolvedValue(undefined);
            });

            test('debe iniciar asignación de póliza', async () => {
                await actionHandler(mockCtx);

                expect(PolicyAssignmentHandler.tieneAsignacionEnProceso).toHaveBeenCalledWith(
                    'user123'
                );
                expect(PolicyAssignmentHandler.mostrarVehiculosDisponibles).toHaveBeenCalledWith(
                    mockBot,
                    123456,
                    'user123'
                );
            });

            test('debe rechazar si ya hay asignación en proceso', async () => {
                PolicyAssignmentHandler.tieneAsignacionEnProceso.mockReturnValue(true);

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '⚠️ Ya tienes una asignación en proceso. Completala o cancelala primero.'
                );
                expect(PolicyAssignmentHandler.mostrarVehiculosDisponibles).not.toHaveBeenCalled();
            });
        });

        describe('vehiculo_cancelar', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'vehiculo_cancelar'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock del VehicleRegistrationHandler
                VehicleRegistrationHandler.tieneRegistroEnProceso = jest.fn().mockReturnValue(true);
                VehicleRegistrationHandler.cancelarRegistro = jest.fn().mockResolvedValue(true);
            });

            test('debe cancelar registro de vehículo', async () => {
                await actionHandler(mockCtx);

                expect(VehicleRegistrationHandler.cancelarRegistro).toHaveBeenCalledWith(
                    'user123',
                    mockBot
                );
                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '✅ Registro cancelado correctamente.'
                );
            });

            test('debe manejar errores', async () => {
                VehicleRegistrationHandler.cancelarRegistro.mockImplementationOnce(() => {
                    throw new Error('Error');
                });

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ Error al cancelar.');
            });
        });

        describe('vehiculo_finalizar', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'vehiculo_finalizar'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock del VehicleRegistrationHandler
                VehicleRegistrationHandler.tieneRegistroEnProceso = jest.fn().mockReturnValue(true);
                VehicleRegistrationHandler.finalizarRegistro = jest.fn().mockResolvedValue(true);
            });

            test('debe finalizar registro de vehículo', async () => {
                await actionHandler(mockCtx);

                expect(VehicleRegistrationHandler.finalizarRegistro).toHaveBeenCalledWith(
                    'user123',
                    mockBot
                );
                expect(mockCtx.answerCbQuery).toHaveBeenCalled();
            });

            test('debe manejar caso sin registro en proceso', async () => {
                // Mock registro no encontrado
                VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(false);

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ No hay registro en proceso.');
            });
        });

        describe('poliza_cancelar', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'poliza_cancelar'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock del PolicyAssignmentHandler
                PolicyAssignmentHandler.tieneAsignacionEnProceso = jest.fn().mockReturnValue(true);
                PolicyAssignmentHandler.cancelarAsignacion = jest.fn().mockResolvedValue(true);
            });

            test('debe cancelar asignación de póliza', async () => {
                await actionHandler(mockCtx);

                expect(PolicyAssignmentHandler.cancelarAsignacion).toHaveBeenCalledWith(
                    'user123',
                    mockBot
                );
                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '✅ Asignación de póliza cancelada correctamente.'
                );
            });

            test('debe manejar errores', async () => {
                PolicyAssignmentHandler.cancelarAsignacion.mockImplementationOnce(() => {
                    throw new Error('Error');
                });

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ Error al cancelar la asignación.');
            });
        });

        describe('asignar_', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => Array.isArray(call[0]) || call[0].toString().includes('asignar_')
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock match y PolicyAssignmentHandler
                mockCtx.match = ['asignar_1234', '1234'];
                PolicyAssignmentHandler.seleccionarVehiculo = jest.fn().mockResolvedValue(undefined);
            });

            test('debe iniciar asignación para vehículo seleccionado', async () => {
                await actionHandler(mockCtx);

                expect(PolicyAssignmentHandler.seleccionarVehiculo).toHaveBeenCalledWith(
                    mockBot,
                    '1234',
                    123456,
                    'user123'
                );
                expect(mockCtx.answerCbQuery).toHaveBeenCalled();
            });

            test('debe manejar errores', async () => {
                PolicyAssignmentHandler.seleccionarVehiculo.mockRejectedValueOnce(
                    new Error('Error')
                );

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ Error al seleccionar vehículo.');
            });
        });

        describe('vehiculos_pag_', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => Array.isArray(call[0]) || call[0].toString().includes('vehiculos_pag_')
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock match y PolicyAssignmentHandler
                mockCtx.match = ['vehiculos_pag_2', '2'];
                PolicyAssignmentHandler.mostrarVehiculosPagina = jest.fn().mockResolvedValue(undefined);
            });

            test('debe mostrar página de vehículos', async () => {
                await actionHandler(mockCtx);

                expect(PolicyAssignmentHandler.mostrarVehiculosPagina).toHaveBeenCalledWith(
                    mockBot,
                    123456,
                    'user123',
                    2
                );
            });

            test('debe manejar errores', async () => {
                PolicyAssignmentHandler.mostrarVehiculosPagina.mockRejectedValueOnce(
                    new Error('Error')
                );

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith(
                    '❌ Error al mostrar la lista de vehículos.'
                );
            });
        });

        describe('accion:volver_menu', () => {
            let actionHandler: Function;

            beforeEach(() => {
                const actionCall = mockBot.action.mock.calls.find(
                    (call: any) => call[0] === 'accion:volver_menu'
                );
                actionHandler = actionCall ? actionCall[1] : () => {};

                // Mock teclado
                const teclados = require('../../../src/comandos/teclados');
                teclados.getMainKeyboard.mockReturnValue({
                    reply_markup: { inline_keyboard: [] }
                });
            });

            test('debe volver al menú principal', async () => {
                await actionHandler(mockCtx);

                expect(mockCtx.editMessageText).toHaveBeenCalledWith(
                    '🤖 *Menú Principal*\n\nSelecciona una opción del menú:',
                    expect.objectContaining({
                        parse_mode: 'Markdown'
                    })
                );
            });

            test('debe manejar errores al volver al menú', async () => {
                mockCtx.editMessageText.mockRejectedValueOnce(new Error('Error de red'));

                await actionHandler(mockCtx);

                expect(mockCtx.reply).toHaveBeenCalledWith('❌ Error al volver al menú.');
            });
        });
    });

    describe('procesarMensajeBaseAutos', () => {
        let message: { chat: { id: number }, text: string };

        beforeEach(() => {
            message = {
                chat: { id: 123456 },
                text: 'mensaje de prueba'
            };

            VehicleRegistrationHandler.tieneRegistroEnProceso = jest.fn();
            VehicleRegistrationHandler.procesarMensaje = jest.fn();
            PolicyAssignmentHandler.tieneAsignacionEnProceso = jest.fn();
            PolicyAssignmentHandler.procesarMensaje = jest.fn();
        });

        test('debe procesar mensaje de registro de vehículo', async () => {
            VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(true);
            VehicleRegistrationHandler.procesarMensaje.mockResolvedValue(true);
            PolicyAssignmentHandler.tieneAsignacionEnProceso.mockReturnValue(false);

            const resultado = await command.procesarMensajeBaseAutos(message, 'user123');

            expect(resultado).toBe(true);
            expect(VehicleRegistrationHandler.procesarMensaje).toHaveBeenCalledWith(
                mockBot,
                message,
                'user123'
            );
            expect(PolicyAssignmentHandler.procesarMensaje).not.toHaveBeenCalled();
        });

        test('debe procesar mensaje de asignación de póliza', async () => {
            VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(false);
            PolicyAssignmentHandler.tieneAsignacionEnProceso.mockReturnValue(true);
            PolicyAssignmentHandler.procesarMensaje.mockResolvedValue(true);

            const resultado = await command.procesarMensajeBaseAutos(message, 'user123');

            expect(resultado).toBe(true);
            expect(PolicyAssignmentHandler.procesarMensaje).toHaveBeenCalledWith(
                mockBot,
                message,
                'user123'
            );
            expect(VehicleRegistrationHandler.procesarMensaje).not.toHaveBeenCalled();
        });

        test('debe retornar false si no hay flujos activos', async () => {
            VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(false);
            PolicyAssignmentHandler.tieneAsignacionEnProceso.mockReturnValue(false);

            const resultado = await command.procesarMensajeBaseAutos(message, 'user123');

            expect(resultado).toBe(false);
            expect(VehicleRegistrationHandler.procesarMensaje).not.toHaveBeenCalled();
            expect(PolicyAssignmentHandler.procesarMensaje).not.toHaveBeenCalled();
        });

        test('debe manejar errores en procesamiento', async () => {
            VehicleRegistrationHandler.tieneRegistroEnProceso.mockImplementation(() => {
                throw new Error('Error de prueba');
            });

            const resultado = await command.procesarMensajeBaseAutos(message, 'user123');

            expect(resultado).toBe(false);
        });

        test('debe continuar con asignación si registro no procesa', async () => {
            VehicleRegistrationHandler.tieneRegistroEnProceso.mockReturnValue(true);
            VehicleRegistrationHandler.procesarMensaje.mockResolvedValue(false);
            PolicyAssignmentHandler.tieneAsignacionEnProceso.mockReturnValue(true);
            PolicyAssignmentHandler.procesarMensaje.mockResolvedValue(true);

            const resultado = await command.procesarMensajeBaseAutos(message, 'user123');

            expect(resultado).toBe(true);
            expect(VehicleRegistrationHandler.procesarMensaje).toHaveBeenCalled();
            expect(PolicyAssignmentHandler.procesarMensaje).toHaveBeenCalled();
        });
    });
});
