import { jest } from '@jest/globals';
import { ExcelUploadHandler } from '../../../src/comandos/comandos/ExcelUploadHandler';
import * as XLSX from 'xlsx';
import type { Context } from 'telegraf';

// Mock dependencies
jest.mock('node-fetch');
jest.mock('../../../src/controllers/policyController');
jest.mock('../../../src/utils/logger', () => ({
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn()
}));

// Mock mongoose to avoid schema issues
jest.mock('mongoose', () => ({
    Schema: jest.fn().mockImplementation(() => ({
        index: jest.fn(),
        pre: jest.fn(),
        methods: {}
    })),
    model: jest.fn(),
    connect: jest.fn()
}));

interface MockCommandHandler {
    bot: any;
    excelUploadMessages: Map<number, number>;
}

interface MockContext {
    chat: { id: number };
    id?: number;
    reply: jest.MockedFunction<any>;
    telegram: {
        editMessageText: jest.MockedFunction<any>;
        deleteMessage: jest.MockedFunction<any>;
    };
    editMessageText?: jest.MockedFunction<any>;
    deleteMessage?: jest.MockedFunction<any>;
}

interface PolicyData {
    titular: string;
    rfc: string;
    marca: string;
    submarca: string;
    año: string | number;
    color: string;
    serie: string;
    placas: string;
    agenteCotizador: string;
    aseguradora: string;
    numeroPoliza: string;
    fechaEmision: string;
    [key: string]: any;
}

interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

interface ProcessResults {
    total: number;
    successful: number;
    failed: number;
    details: Array<{
        numeroPoliza: string;
        status: 'SUCCESS' | 'ERROR';
        message: string;
    }>;
}

describe('ExcelUploadHandler', () => {
    let handler: ExcelUploadHandler;
    let mockCommandHandler: MockCommandHandler;
    let mockContext: MockContext;
    let mockPolicyController: any;

    beforeEach(async () => {
        // Dynamic import for mocked controller
        const policyControllerModule = await import('../../../src/controllers/policyController');
        mockPolicyController = policyControllerModule;
        
        // Mock command handler
        mockCommandHandler = {
            bot: {},
            excelUploadMessages: new Map()
        };

        // Create handler instance
        handler = new ExcelUploadHandler(mockCommandHandler);

        // Mock Telegram context
        mockContext = {
            chat: { id: 12345 },
            reply: jest.fn().mockResolvedValue({ message_id: 1 }),
            telegram: {
                editMessageText: jest.fn().mockResolvedValue({}),
                deleteMessage: jest.fn().mockResolvedValue({})
            }
        };

        // Reset mocks
        jest.clearAllMocks();
        if (mockPolicyController.savePolicy) {
            mockPolicyController.savePolicy.mockClear();
        }
    });

    describe('isExcelFile', () => {
        test('should return true for valid Excel extensions', () => {
            expect(handler.isExcelFile('application/octet-stream', 'test.xlsx')).toBe(true);
            expect(handler.isExcelFile('application/octet-stream', 'test.xls')).toBe(true);
            expect(handler.isExcelFile('application/octet-stream', 'test.xlsm')).toBe(true);
        });

        test('should return true for valid Excel MIME types', () => {
            expect(
                handler.isExcelFile(
                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    'file'
                )
            ).toBe(true);
            expect(handler.isExcelFile('application/vnd.ms-excel', 'file')).toBe(true);
        });

        test('should return false for invalid files', () => {
            expect(handler.isExcelFile('application/pdf', 'test.pdf')).toBe(false);
            expect(handler.isExcelFile('text/plain', 'test.txt')).toBe(false);
            expect(handler.isExcelFile('image/jpeg', 'test.jpg')).toBe(false);
        });
    });

    describe('validateHeaders', () => {
        test('should return true for valid headers', () => {
            const validHeaders: string[] = [
                'TITULAR',
                'RFC',
                'MARCA',
                'SUBMARCA',
                'AÑO',
                'COLOR',
                'SERIE',
                'PLACAS',
                'AGENTE COTIZADOR',
                'ASEGURADORA',
                '# DE POLIZA',
                'FECHA DE EMISION'
            ];

            expect(handler.validateHeaders(validHeaders)).toBe(true);
        });

        test('should return false for missing required headers', () => {
            const invalidHeaders: string[] = [
                'TITULAR',
                'RFC',
                'MARCA'
                // Missing other required fields
            ];

            expect(handler.validateHeaders(invalidHeaders)).toBe(false);
        });

        test('should handle case insensitivity', () => {
            const mixedCaseHeaders: string[] = [
                'titular',
                'Rfc',
                'MARCA',
                'submarca',
                'Año',
                'COLOR',
                'serie',
                'Placas',
                'agente cotizador',
                'ASEGURADORA',
                '# de poliza',
                'fecha de emision'
            ];

            expect(handler.validateHeaders(mixedCaseHeaders)).toBe(true);
        });

        test('should handle alternative header formats', () => {
            const alternativeHeaders: string[] = [
                'NOMBRE DEL TITULAR',
                'RFC',
                'MARCA',
                'SUBMARCA',
                'AÑO',
                'COLOR',
                'SERIE',
                'PLACAS',
                'AGENTE',
                'ASEGURADORA',
                'NUMERO DE POLIZA',
                'FECHA EMISION'
            ];

            expect(handler.validateHeaders(alternativeHeaders)).toBe(true);
        });
    });

    describe('mapHeadersToFields', () => {
        test('should correctly map standard headers to field names', () => {
            const headers: string[] = [
                'TITULAR',
                'RFC',
                'MARCA',
                'SUBMARCA',
                'AÑO',
                'COLOR',
                'SERIE',
                'PLACAS',
                'AGENTE COTIZADOR',
                'ASEGURADORA',
                '# DE POLIZA',
                'FECHA DE EMISION'
            ];

            const result = handler.mapHeadersToFields(headers);
            
            expect(result).toEqual({
                'TITULAR': 'titular',
                'RFC': 'rfc',
                'MARCA': 'marca',
                'SUBMARCA': 'submarca',
                'AÑO': 'año',
                'COLOR': 'color',
                'SERIE': 'serie',
                'PLACAS': 'placas',
                'AGENTE COTIZADOR': 'agenteCotizador',
                'ASEGURADORA': 'aseguradora',
                '# DE POLIZA': 'numeroPoliza',
                'FECHA DE EMISION': 'fechaEmision'
            });
        });

        test('should correctly map alternative headers to field names', () => {
            const headers: string[] = [
                'NOMBRE DEL TITULAR',
                'RFC',
                'MARCA',
                'SUBMARCA',
                'AÑO MODELO',
                'COLOR',
                'SERIE',
                'PLACAS',
                'AGENTE',
                'COMPAÑIA',
                'NUMERO DE POLIZA',
                'FECHA INICIO'
            ];

            const result = handler.mapHeadersToFields(headers);
            
            expect(result).toEqual({
                'NOMBRE DEL TITULAR': 'titular',
                'RFC': 'rfc',
                'MARCA': 'marca',
                'SUBMARCA': 'submarca',
                'AÑO MODELO': 'año',
                'COLOR': 'color',
                'SERIE': 'serie',
                'PLACAS': 'placas',
                'AGENTE': 'agenteCotizador',
                'COMPAÑIA': 'aseguradora',
                'NUMERO DE POLIZA': 'numeroPoliza',
                'FECHA INICIO': 'fechaEmision'
            });
        });
    });

    describe('validatePolicyData', () => {
        test('should validate valid policy data', () => {
            const validData: PolicyData = {
                titular: 'Juan Pérez',
                rfc: 'PERJ800101ABC',
                marca: 'NISSAN',
                submarca: 'SENTRA',
                año: 2020,
                color: 'BLANCO',
                serie: '1N4AL11D32C123456',
                placas: 'ABC123',
                agenteCotizador: 'Agente Test',
                aseguradora: 'Aseguradora Test',
                numeroPoliza: 'POL123456',
                fechaEmision: '2023-01-01'
            };

            const result = handler.validatePolicyData(validData);
            expect(result.isValid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });

        test('should detect missing required fields', () => {
            const invalidData: PolicyData = {
                titular: '',
                rfc: 'PERJ800101ABC',
                marca: 'NISSAN',
                submarca: 'SENTRA',
                año: 2020,
                color: 'BLANCO',
                serie: '',
                placas: 'ABC123',
                agenteCotizador: 'Agente Test',
                aseguradora: 'Aseguradora Test',
                numeroPoliza: '',
                fechaEmision: '2023-01-01'
            };

            const result = handler.validatePolicyData(invalidData);
            expect(result.isValid).toBe(false);
            expect(result.errors).toHaveLength(3);
            expect(result.errors).toContain('Falta TITULAR');
            expect(result.errors).toContain('Falta SERIE');
            expect(result.errors).toContain('Falta # DE POLIZA');
        });

        test('should validate data formats', () => {
            const invalidData: PolicyData = {
                titular: 'Juan Pérez',
                rfc: 'PERJ800101ABC',
                marca: 'NISSAN',
                submarca: 'SENTRA',
                año: 'invalid',
                color: 'BLANCO',
                serie: '1N4AL11D32C123456',
                placas: 'ABC123',
                agenteCotizador: 'Agente Test',
                aseguradora: 'Aseguradora Test',
                numeroPoliza: 'POL123456',
                fechaEmision: 'invalid'
            };

            const result = handler.validatePolicyData(invalidData);
            expect(result.isValid).toBe(false);
            expect(result.errors).toContain('AÑO debe ser un número válido');
            expect(result.errors).toContain('FECHA DE EMISION no es válida');
        });

        test('should validate multiple errors', () => {
            const invalidData: PolicyData = {
                titular: '',
                rfc: 'PERJ800101ABC',
                marca: 'NISSAN',
                submarca: 'SENTRA',
                año: 'invalid',
                color: 'BLANCO',
                serie: '1N4AL11D32C123456',
                placas: 'ABC123',
                agenteCotizador: 'Agente Test',
                aseguradora: 'Aseguradora Test',
                numeroPoliza: 'POL123456',
                fechaEmision: 'invalid'
            };

            const result = handler.validatePolicyData(invalidData);
            expect(result.isValid).toBe(false);
            expect(result.errors).toHaveLength(3);
            expect(result.errors).toContain('Falta TITULAR');
            expect(result.errors).toContain('AÑO debe ser un número válido');
            expect(result.errors).toContain('FECHA DE EMISION no es válida');
        });
    });

    describe('showResults', () => {
        test('should display results correctly', async () => {
            const results: ProcessResults = {
                total: 3,
                successful: 2,
                failed: 1,
                details: [
                    {
                        numeroPoliza: 'POL123',
                        status: 'SUCCESS',
                        message: 'Registrada correctamente'
                    },
                    {
                        numeroPoliza: 'POL456',
                        status: 'SUCCESS',
                        message: 'Registrada correctamente'
                    },
                    {
                        numeroPoliza: 'POL789',
                        status: 'ERROR',
                        message: 'Falta TITULAR, Falta RFC'
                    }
                ]
            };

            await handler.showResults(mockContext as Context, results);

            // Check main summary message
            expect(mockContext.reply).toHaveBeenCalledWith(
                expect.stringContaining('*Resumen del Procesamiento*'),
                expect.objectContaining({ parse_mode: 'Markdown' })
            );

            // Check successful policies message
            expect(mockContext.reply).toHaveBeenCalledWith(
                '✅ *Pólizas Registradas Correctamente:*',
                expect.objectContaining({ parse_mode: 'Markdown' })
            );

            // Check failed policies message
            expect(mockContext.reply).toHaveBeenCalledWith(
                '❌ *Pólizas con Errores:*',
                expect.objectContaining({ parse_mode: 'Markdown' })
            );

            // Check that policy numbers are displayed without dashes
            expect(mockContext.reply).toHaveBeenCalledWith('POL123\nPOL456');
            expect(mockContext.reply).toHaveBeenCalledWith(
                '*POL789*: Falta TITULAR, Falta RFC',
                expect.objectContaining({ parse_mode: 'Markdown' })
            );
        });

        test('should handle empty results', async () => {
            const results: ProcessResults = {
                total: 0,
                successful: 0,
                failed: 0,
                details: []
            };

            await handler.showResults(mockContext as Context, results);

            expect(mockContext.reply).toHaveBeenCalledWith(
                expect.stringContaining('Total de pólizas procesadas: 0'),
                expect.objectContaining({ parse_mode: 'Markdown' })
            );
        });
    });

    describe('State Management', () => {
        test('should set and unset awaiting Excel upload state', () => {
            const chatId = 12345;

            // Initially should not be awaiting
            expect(handler.awaitingExcelUpload.has(chatId)).toBe(false);

            // Set awaiting state
            handler.setAwaitingExcelUpload(chatId, true);
            expect(handler.awaitingExcelUpload.get(chatId)).toBe(true);

            // Unset awaiting state
            handler.setAwaitingExcelUpload(chatId, false);
            expect(handler.awaitingExcelUpload.has(chatId)).toBe(false);
        });
    });
});
