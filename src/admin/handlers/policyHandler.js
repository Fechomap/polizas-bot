const { Markup } = require('telegraf');
const Policy = require('../../models/policy');
const AdminStateManager = require('../utils/adminStates');
const { AuditLogger } = require('../utils/auditLogger');
const AdminMenu = require('../menus/adminMenu');
const logger = require('../../utils/logger');
const { 
    markPolicyAsDeleted, 
    restorePolicy,
    getPolicyByNumber 
} = require('../../controllers/policyController');

class PolicyHandler {
    /**
   * Maneja las acciones relacionadas con p√≥lizas
   */
    static async handleAction(ctx, action) {
        try {
            switch (action) {
            case 'menu':
                return await AdminMenu.showPolicyMenu(ctx);

            case 'edit':
                return await this.handlePolicyEdit(ctx);

            case 'delete':
                return await this.handlePolicyDelete(ctx);

            case 'restore':
                return await this.handlePolicyRestore(ctx);

            case 'stats':
                return await this.handleStats(ctx);

            default:
                await ctx.answerCbQuery('Opci√≥n no disponible', { show_alert: true });
            }
        } catch (error) {
            logger.error('Error en PolicyHandler:', error);
            await ctx.answerCbQuery('Error al procesar la solicitud', { show_alert: true });
        }
    }

    /**
     * Inicia el flujo de edici√≥n de p√≥liza
     */
    static async handlePolicyEdit(ctx) {
        try {
            AdminStateManager.clearAdminState(ctx.from.id, ctx.chat.id);
            AdminStateManager.createAdminState(
                ctx.from.id,
                ctx.chat.id,
                'policy_search_for_edit'
            );

            const searchText = `
üîç *BUSCAR P√ìLIZA PARA EDITAR*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Escribe uno de los siguientes datos para buscar:

üìù *N√∫mero de p√≥liza* - Ejemplo: ABC123456
üë§ *Nombre del titular* - Ejemplo: Juan P√©rez
üÜî *RFC* - Ejemplo: JURP850101XXX

_El sistema buscar√° autom√°ticamente y mostrar√° las coincidencias._
            `.trim();

            const keyboard = Markup.inlineKeyboard([
                [Markup.button.callback('‚ùå Cancelar', 'admin_policy_menu')]
            ]);

            await ctx.editMessageText(searchText, {
                parse_mode: 'Markdown',
                ...keyboard
            });

            await AuditLogger.log(ctx, 'policy_search_initiated', 'policy', {
                operation: 'search_for_edit'
            });

        } catch (error) {
            logger.error('Error al iniciar b√∫squeda de p√≥liza:', error);
            await ctx.reply('‚ùå Error al iniciar la b√∫squeda. Intenta nuevamente.');
        }
    }

    /**
     * Procesa la b√∫squeda de p√≥lizas
     */
    static async handlePolicySearch(ctx, searchTerm) {
        try {
            // Detectar si hay m√∫ltiples t√©rminos (separados por saltos de l√≠nea)
            const terms = searchTerm.split('\n').map(t => t.trim()).filter(t => t.length > 0);
            
            let searchResults = [];
            let processedTerms = [];
            
            if (terms.length > 1) {
                // B√∫squeda m√∫ltiple
                for (const term of terms.slice(0, 5)) { // M√°ximo 5 t√©rminos
                    const results = await this.searchPolicies(term);
                    searchResults.push(...results);
                    processedTerms.push(term);
                }
                
                // Eliminar duplicados por _id
                const uniqueResults = searchResults.filter((policy, index, self) => 
                    index === self.findIndex(p => p._id.toString() === policy._id.toString())
                );
                searchResults = uniqueResults;
                
                if (searchResults.length === 0) {
                    const noResultsText = `
‚ùå *SIN RESULTADOS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

No se encontraron p√≥lizas con ninguno de los ${terms.length} t√©rminos buscados.

**T√©rminos buscados:**
${terms.map((t, i) => `${i+1}. ${t}`).join('\n')}

_Intenta con t√©rminos individuales o verifica la ortograf√≠a._
                    `.trim();
                } else {
                    // Mostrar resultados m√∫ltiples
                    await this.showMultipleSearchResults(ctx, searchResults, processedTerms);
                    return;
                }
            } else {
                // B√∫squeda simple
                searchResults = await this.searchPolicies(searchTerm);
            }

            if (searchResults.length === 0) {
                const noResultsText = `
‚ùå *SIN RESULTADOS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

No se encontraron p√≥lizas con: "${searchTerm}"

Verifica que:
‚Ä¢ El n√∫mero de p√≥liza sea correcto
‚Ä¢ El nombre est√© completo
‚Ä¢ El RFC tenga el formato correcto

_Intenta con otro t√©rmino de b√∫squeda._
                `.trim();

                const keyboard = Markup.inlineKeyboard([
                    [Markup.button.callback('üîç Nueva B√∫squeda', 'admin_policy_edit')],
                    [Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')]
                ]);

                try {
                    await ctx.editMessageText(noResultsText, {
                        parse_mode: 'Markdown',
                        ...keyboard
                    });
                } catch (error) {
                    await ctx.reply(noResultsText, {
                        parse_mode: 'Markdown',
                        ...keyboard
                    });
                }
                return;
            }

            if (searchResults.length === 1) {
                await this.showPolicyDetails(ctx, searchResults[0]);
            } else {
                await this.showSearchResults(ctx, searchResults, searchTerm);
            }

            await AuditLogger.log(ctx, 'policy_search_completed', 'policy', {
                searchTerm,
                resultsCount: searchResults.length
            });

        } catch (error) {
            logger.error('Error al buscar p√≥lizas:', error);
            await ctx.reply('‚ùå Error en la b√∫squeda. Intenta nuevamente.');
        }
    }

    /**
     * Busca p√≥lizas en la base de datos
     */
    static async searchPolicies(searchTerm) {
        const cleanTerm = searchTerm.trim();

        const searchQuery = {
            estado: { $ne: 'ELIMINADO' },
            $or: [
                { numeroPoliza: { $regex: cleanTerm, $options: 'i' } },
                { titular: { $regex: cleanTerm, $options: 'i' } },
                { rfc: { $regex: cleanTerm, $options: 'i' } }
            ]
        };

        const policies = await Policy.find(searchQuery)
            .select('numeroPoliza titular rfc correo contrase√±a calle colonia municipio estadoRegion cp agenteCotizador aseguradora fechaEmision telefono estadoPoliza fechaFinCobertura fechaFinGracia marca submarca a√±o color serie placas calificacion totalServicios servicios registros estado fechaEliminacion motivoEliminacion')
            .sort({ fechaEmision: -1 })
            .limit(10);

        return policies;
    }

    /**
     * Muestra resultados de b√∫squeda m√∫ltiple
     */
    static async showMultipleSearchResults(ctx, results, processedTerms) {
        let resultText = `
üîç *RESULTADOS B√öSQUEDA M√öLTIPLE*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Encontradas: ${results.length} p√≥lizas √∫nicas
T√©rminos: ${processedTerms.length}

Selecciona una p√≥liza:

`;

        const buttons = [];
        results.forEach((policy, index) => {
            const policyInfo = `${policy.numeroPoliza} - ${policy.titular}`;
            resultText += `${index + 1}. ${policyInfo}\n`;
            
            buttons.push([
                Markup.button.callback(
                    `${index + 1}. ${policy.numeroPoliza}`,
                    `admin_policy_select:${policy._id}`
                )
            ]);
        });

        buttons.push([
            Markup.button.callback('üîç Nueva B√∫squeda', 'admin_policy_edit'),
            Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')
        ]);

        const keyboard = Markup.inlineKeyboard(buttons);

        try {
            await ctx.editMessageText(resultText.trim(), {
                parse_mode: 'Markdown',
                ...keyboard
            });
        } catch (error) {
            await ctx.reply(resultText.trim(), {
                parse_mode: 'Markdown',
                ...keyboard
            });
        }

        AdminStateManager.updateAdminState(ctx.from.id, ctx.chat.id, {
            searchResults: results.map(p => p._id.toString()),
            searchTerms: processedTerms
        });
    }

    /**
     * Muestra m√∫ltiples resultados de b√∫squeda
     */
    static async showSearchResults(ctx, results, searchTerm) {
        let resultText = `
üîç *RESULTADOS DE B√öSQUEDA*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

B√∫squeda: "${searchTerm}"
Encontradas: ${results.length} p√≥lizas

Selecciona una p√≥liza:

`;

        const buttons = [];
        results.forEach((policy, index) => {
            const policyInfo = `${policy.numeroPoliza} - ${policy.titular}`;
            resultText += `${index + 1}. ${policyInfo}\n`;

            buttons.push([
                Markup.button.callback(
                    `${index + 1}. ${policy.numeroPoliza}`,
                    `admin_policy_select:${policy._id}`
                )
            ]);
        });

        buttons.push([
            Markup.button.callback('üîç Nueva B√∫squeda', 'admin_policy_edit'),
            Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')
        ]);

        const keyboard = Markup.inlineKeyboard(buttons);

        try {
            await ctx.editMessageText(resultText.trim(), {
                parse_mode: 'Markdown',
                ...keyboard
            });
        } catch (error) {
            await ctx.reply(resultText.trim(), {
                parse_mode: 'Markdown',
                ...keyboard
            });
        }

        AdminStateManager.updateAdminState(ctx.from.id, ctx.chat.id, {
            searchResults: results.map(p => p._id.toString()),
            searchTerm
        });
    }

    /**
     * Muestra los detalles de una p√≥liza espec√≠fica
     */
    static async showPolicyDetails(ctx, policy) {
        const formatDate = (date) => {
            if (!date) return 'No definida';
            return new Date(date).toLocaleDateString('es-MX');
        };

        const formatPhone = (phone) => {
            if (!phone) return 'No definido';
            // Formatear tel√©fono mexicano: 5526538255 -> (55) 2653-8255
            if (phone.length === 10) {
                return `(${phone.slice(0,2)}) ${phone.slice(2,6)}-${phone.slice(6)}`;
            }
            return phone;
        };

        // Calcular servicios y registros reales
        const serviciosReales = policy.servicios?.length || 0;
        const registrosReales = policy.registros?.length || 0;
        
        const detailsText = `
üìã *DETALLES DE P√ìLIZA*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

**INFORMACI√ìN B√ÅSICA**
üîñ N√∫mero: ${policy.numeroPoliza}
üë§ Titular: ${policy.titular}
üÜî RFC: ${policy.rfc}
üìß Email: ${policy.correo || 'No definido'}
üìû Tel√©fono: ${formatPhone(policy.telefono)}

**DIRECCI√ìN**
üè† ${policy.calle || 'N/A'}
üèòÔ∏è Col. ${policy.colonia || 'N/A'}
üèôÔ∏è ${policy.municipio || 'N/A'}, ${policy.estadoRegion || 'N/A'}
üìÆ CP: ${policy.cp || 'N/A'}

**VEH√çCULO**
üöó ${policy.marca || 'N/A'} ${policy.submarca || 'N/A'} (${policy.a√±o || 'N/A'})
üé® Color: ${policy.color || 'No definido'}
üî¢ Serie: ${policy.serie || 'No definida'}
üöô Placas: ${policy.placas || 'No definidas'}

**P√ìLIZA**
üè¢ Aseguradora: ${policy.aseguradora}
üë®‚Äçüíº Agente: ${policy.agenteCotizador || 'No definido'}
üìÖ Emisi√≥n: ${formatDate(policy.fechaEmision)}
üìä Estado P√≥liza: ${policy.estadoPoliza || 'No definido'}
üóìÔ∏è Fin Cobertura: ${formatDate(policy.fechaFinCobertura)}

**SERVICIOS**
üìä Servicios: ${serviciosReales}
üìã Registros: ${registrosReales}
‚≠ê Calificaci√≥n: ${policy.calificacion || 0}/5
üìà Estado: ${policy.estado}

¬øQu√© deseas hacer con esta p√≥liza?
        `.trim();

        const keyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback('‚úèÔ∏è Editar Datos', `admin_policy_edit_data:${policy._id}`),
                Markup.button.callback('üìã Ver Servicios', `admin_policy_view_services:${policy._id}`)
            ],
            [
                Markup.button.callback('üóëÔ∏è Eliminar', `admin_policy_delete_confirm:${policy._id}`),
                Markup.button.callback('üìÑ Ver Archivos', `admin_policy_view_files:${policy._id}`)
            ],
            [
                Markup.button.callback('üîç Nueva B√∫squeda', 'admin_policy_edit'),
                Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')
            ]
        ]);

        try {
            await ctx.editMessageText(detailsText, {
                parse_mode: 'Markdown',
                ...keyboard
            });
        } catch (error) {
            // Si no se puede editar, enviar mensaje nuevo
            await ctx.reply(detailsText, {
                parse_mode: 'Markdown',
                ...keyboard
            });
        }

        AdminStateManager.updateAdminState(ctx.from.id, ctx.chat.id, {
            selectedPolicy: policy._id.toString(),
            operation: 'policy_selected'
        });

        await AuditLogger.log(ctx, 'policy_viewed', 'policy', {
            policyId: policy._id.toString(),
            policyNumber: policy.numeroPoliza
        });
    }

    /**
     * Maneja la selecci√≥n de una p√≥liza espec√≠fica por ID
     */
    static async handlePolicySelection(ctx, policyId) {
        try {
            const policy = await Policy.findById(policyId);

            if (!policy) {
                await ctx.reply('‚ùå P√≥liza no encontrada.');
                return;
            }

            await this.showPolicyDetails(ctx, policy);

        } catch (error) {
            logger.error('Error al seleccionar p√≥liza:', error);
            await ctx.reply('‚ùå Error al cargar la p√≥liza.');
        }
    }

    /**
     * Procesa mensajes de texto durante la b√∫squeda
     */
    static async handleTextMessage(ctx) {
        const adminState = AdminStateManager.getAdminState(ctx.from.id, ctx.chat.id);
        
        if (!adminState) {
            return false;
        }

        const messageText = ctx.message.text.trim();

        // Manejar diferentes operaciones admin
        switch (adminState.operation) {
        case 'policy_search_for_edit':
        case 'policy_search_for_delete':
            if (messageText.length < 2) {
                await ctx.reply('‚ùå El t√©rmino de b√∫squeda debe tener al menos 2 caracteres.');
                return true;
            }
            await this.handlePolicySearch(ctx, messageText);
            return true;

        case 'policy_deletion_reason':
            if (messageText.length < 3) {
                await ctx.reply('‚ùå El motivo debe tener al menos 3 caracteres.');
                return true;
            }
            await this.handleDeletionReason(ctx, messageText);
            return true;

        default:
            return false;
        }
    }

    /**
     * Ejecuta la restauraci√≥n de una p√≥liza
     */
    static async handleRestoreExecution(ctx, policyId) {
        try {
            const policy = await Policy.findById(policyId);
            
            if (!policy) {
                await ctx.reply('‚ùå P√≥liza no encontrada.');
                return;
            }

            // Ejecutar restauraci√≥n
            const result = await restorePolicy(policy.numeroPoliza);
            
            if (result) {
                const successText = `
‚úÖ *P√ìLIZA RESTAURADA*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

**P√≥liza:** ${policy.numeroPoliza}
**Titular:** ${policy.titular}
**Fecha Restauraci√≥n:** ${new Date().toLocaleDateString('es-MX')}

La p√≥liza ha sido restaurada y est√° ACTIVA nuevamente.
                `.trim();

                await ctx.editMessageText(successText, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚¨ÖÔ∏è Volver al Men√∫', callback_data: 'admin_policy_menu' }
                        ]]
                    }
                });

                // Log de auditor√≠a
                await AuditLogger.log(ctx, 'policy_restored', 'policy', {
                    policyNumber: policy.numeroPoliza,
                    result: 'success'
                });

            } else {
                await ctx.reply('‚ùå Error: No se pudo restaurar la p√≥liza.');
            }

        } catch (error) {
            logger.error('Error al ejecutar restauraci√≥n:', error);
            await ctx.reply('‚ùå Error al restaurar la p√≥liza.');
        }
    }

    /**
     * Inicia el flujo de eliminaci√≥n de p√≥liza
     */
    static async handlePolicyDelete(ctx) {
        try {
            AdminStateManager.clearAdminState(ctx.from.id, ctx.chat.id);
            AdminStateManager.createAdminState(
                ctx.from.id,
                ctx.chat.id,
                'policy_search_for_delete'
            );

            const searchText = `
üóëÔ∏è *BUSCAR P√ìLIZA PARA ELIMINAR*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö†Ô∏è *ATENCI√ìN: Esta operaci√≥n marca la p√≥liza como eliminada.*

Escribe el n√∫mero de p√≥liza o nombre del titular:

_La eliminaci√≥n es l√≥gica y se puede restaurar posteriormente._
            `.trim();

            const keyboard = Markup.inlineKeyboard([
                [Markup.button.callback('‚ùå Cancelar', 'admin_policy_menu')]
            ]);

            await ctx.editMessageText(searchText, {
                parse_mode: 'Markdown',
                ...keyboard
            });

        } catch (error) {
            logger.error('Error al iniciar eliminaci√≥n:', error);
            await ctx.reply('‚ùå Error al iniciar el proceso. Intenta nuevamente.');
        }
    }

    /**
     * Inicia el flujo de restauraci√≥n de p√≥lizas
     */
    static async handlePolicyRestore(ctx) {
        try {
            const deletedPolicies = await Policy.find({ estado: 'ELIMINADO' })
                .select('numeroPoliza titular rfc fechaEliminacion motivoEliminacion')
                .sort({ fechaEliminacion: -1 })
                .limit(10);

            if (deletedPolicies.length === 0) {
                const noDeletedText = `
‚úÖ *SIN P√ìLIZAS ELIMINADAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

No hay p√≥lizas marcadas como eliminadas.

Todas las p√≥lizas est√°n activas en el sistema.
                `.trim();

                const keyboard = Markup.inlineKeyboard([
                    [Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')]
                ]);

                await ctx.editMessageText(noDeletedText, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
                return;
            }

            await this.showDeletedPolicies(ctx, deletedPolicies);

        } catch (error) {
            logger.error('Error al buscar p√≥lizas eliminadas:', error);
            await ctx.reply('‚ùå Error al cargar p√≥lizas eliminadas.');
        }
    }

    /**
     * Muestra lista de p√≥lizas eliminadas
     */
    static async showDeletedPolicies(ctx, deletedPolicies) {
        let listText = `
üóëÔ∏è *P√ìLIZAS ELIMINADAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Total eliminadas: ${deletedPolicies.length}

Selecciona una para restaurar:

`;

        const buttons = [];
        deletedPolicies.forEach((policy, index) => {
            const deleteDate = new Date(policy.fechaEliminacion).toLocaleDateString('es-MX');
            listText += `${index + 1}. ${policy.numeroPoliza} - ${policy.titular}\n`;
            listText += `   Eliminada: ${deleteDate}\n\n`;

            buttons.push([
                Markup.button.callback(
                    `üîÑ ${index + 1}. ${policy.numeroPoliza}`,
                    `admin_policy_restore_confirm:${policy._id}`
                )
            ]);
        });

        buttons.push([
            [Markup.button.callback('‚¨ÖÔ∏è Volver', 'admin_policy_menu')]
        ]);

        const keyboard = Markup.inlineKeyboard(buttons);

        await ctx.editMessageText(listText.trim(), {
            parse_mode: 'Markdown',
            ...keyboard
        });
    }

    /**
     * Maneja la confirmaci√≥n de eliminaci√≥n de p√≥liza
     */
    static async handleDeleteConfirmation(ctx, policyId) {
        try {
            const policy = await Policy.findById(policyId);
            
            if (!policy) {
                await ctx.reply('‚ùå P√≥liza no encontrada.');
                return;
            }

            const confirmText = `
‚ö†Ô∏è *CONFIRMAR ELIMINACI√ìN*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

¬øEst√°s seguro de eliminar esta p√≥liza?

**P√≥liza:** ${policy.numeroPoliza}
**Titular:** ${policy.titular}

‚ö†Ô∏è Esta acci√≥n es **reversible** (eliminaci√≥n l√≥gica)
‚úÖ Los archivos y servicios se conservar√°n
üîÑ Se puede restaurar posteriormente

Escribe el motivo de eliminaci√≥n o presiona Cancelar:
            `.trim();

            const keyboard = Markup.inlineKeyboard([
                [Markup.button.callback('‚ùå Cancelar', 'admin_policy_menu')]
            ]);

            await ctx.editMessageText(confirmText, {
                parse_mode: 'Markdown',
                ...keyboard
            });

            // Cambiar estado para esperar el motivo
            AdminStateManager.clearAdminState(ctx.from.id, ctx.chat.id);
            AdminStateManager.createAdminState(
                ctx.from.id,
                ctx.chat.id,
                'policy_deletion_reason',
                { policyId, policyNumber: policy.numeroPoliza }
            );

        } catch (error) {
            logger.error('Error en confirmaci√≥n de eliminaci√≥n:', error);
            await ctx.reply('‚ùå Error al procesar la solicitud.');
        }
    }

    /**
     * Maneja la confirmaci√≥n de restauraci√≥n de p√≥liza
     */
    static async handleRestoreConfirmation(ctx, policyId) {
        try {
            const policy = await Policy.findById(policyId);
            
            if (!policy) {
                await ctx.reply('‚ùå P√≥liza no encontrada.');
                return;
            }

            const confirmText = `
üîÑ *CONFIRMAR RESTAURACI√ìN*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

¬øRestaurar esta p√≥liza?

**P√≥liza:** ${policy.numeroPoliza}
**Titular:** ${policy.titular}
**Eliminada:** ${new Date(policy.fechaEliminacion).toLocaleDateString('es-MX')}
**Motivo:** ${policy.motivoEliminacion || 'No especificado'}

‚úÖ La p√≥liza volver√° a estar ACTIVA
            `.trim();

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('‚úÖ S√≠, Restaurar', `admin_policy_restore_execute:${policyId}`),
                    Markup.button.callback('‚ùå Cancelar', 'admin_policy_restore')
                ]
            ]);

            await ctx.editMessageText(confirmText, {
                parse_mode: 'Markdown',
                ...keyboard
            });

        } catch (error) {
            logger.error('Error en confirmaci√≥n de restauraci√≥n:', error);
            await ctx.reply('‚ùå Error al procesar la solicitud.');
        }
    }

    /**
     * Procesa el motivo de eliminaci√≥n y ejecuta la eliminaci√≥n
     */
    static async handleDeletionReason(ctx, reason) {
        try {
            const adminState = AdminStateManager.getAdminState(ctx.from.id, ctx.chat.id);
            
            if (!adminState || adminState.operation !== 'policy_deletion_reason') {
                return false;
            }

            const { policyNumber } = adminState.data;
            
            // Ejecutar eliminaci√≥n l√≥gica
            const result = await markPolicyAsDeleted(policyNumber, reason);
            
            if (result) {
                const successText = `
‚úÖ *P√ìLIZA ELIMINADA*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

**P√≥liza:** ${policyNumber}
**Motivo:** ${reason}
**Fecha:** ${new Date().toLocaleDateString('es-MX')}

La p√≥liza ha sido marcada como ELIMINADA.
Se puede restaurar desde "Restaurar P√≥liza".
                `.trim();

                await ctx.reply(successText, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚¨ÖÔ∏è Volver al Men√∫', callback_data: 'admin_policy_menu' }
                        ]]
                    }
                });

                // Log de auditor√≠a
                await AuditLogger.log(ctx, 'policy_deleted', 'policy', {
                    policyNumber,
                    reason,
                    result: 'success'
                });

            } else {
                await ctx.reply('‚ùå Error: No se pudo eliminar la p√≥liza. Verifica que est√© activa.');
            }

            // Limpiar estado
            AdminStateManager.clearAdminState(ctx.from.id, ctx.chat.id);
            return true;

        } catch (error) {
            logger.error('Error al procesar eliminaci√≥n:', error);
            await ctx.reply('‚ùå Error al eliminar la p√≥liza.');
            AdminStateManager.clearAdminState(ctx.from.id, ctx.chat.id);
            return true;
        }
    }

    /**
   * Muestra estad√≠sticas de p√≥lizas
   */
    static async handleStats(ctx) {
    // Por ahora mostrar placeholder
        const statsText = `
üìä *ESTAD√çSTICAS DE P√ìLIZAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìã Total P√≥lizas: _Calculando..._
‚úÖ Activas: _Calculando..._
‚ùå Eliminadas: _Calculando..._
üìÖ Registradas este mes: _Calculando..._

_Las estad√≠sticas completas estar√°n disponibles en la Fase 4._
    `.trim();

        await ctx.editMessageText(statsText, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [[
                    { text: '‚¨ÖÔ∏è Volver', callback_data: 'admin_policy_menu' }
                ]]
            }
        });
    }
}

module.exports = PolicyHandler;
