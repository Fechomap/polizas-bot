import { Context, Markup } from 'telegraf';
import { Message } from 'telegraf/typings/core/types/typegram';
import { BaseCommand, IBaseHandler } from './BaseCommand';
import logger from '../../utils/logger';
import {
    getPolicyByNumber,
    convertirRegistroAServicio,
    marcarRegistroNoAsignado,
    calcularHorasAutomaticas
} from '../../controllers/policyController';
import StateKeyManager from '../../utils/StateKeyManager';
import { getInstance } from '../../services/NotificationManager';
import HereMapsService from '../../services/HereMapsService';
import { IPolicy } from '../../types/database';
import type { IThreadSafeStateMap } from '../../utils/StateKeyManager';
import flowStateManager from '../../utils/FlowStateManager';

interface IScheduledServiceInfo {
    numeroPoliza: string;
    expediente?: string;
    contactTime?: string;
    origin?: string;
    destination?: string;
    origenDestino?: string;
    scheduledDate?: Date;
    policy?: IPolicy;
}

interface IHandler extends IBaseHandler {
    awaitingPhoneNumber: IThreadSafeStateMap<string>;
    awaitingOrigenDestino: IThreadSafeStateMap<string>;
    awaitingOrigen: IThreadSafeStateMap<string>;
    awaitingDestino: IThreadSafeStateMap<string>;
    awaitingServiceData: IThreadSafeStateMap<string>;
    awaitingServicePolicyNumber: IThreadSafeStateMap<boolean>;
    excelUploadMessages?: Map<number, number>;
    processingCallbacks?: Set<string>;
    uploadTargets: IThreadSafeStateMap<string>;
    registry: {
        registerCallback(pattern: RegExp, handler: (ctx: Context) => Promise<void>): void;
        getAllCommands(): Array<{
            getCommandName(): string;
            procesarDocumentoBaseAutos?(message: Message, userId: string): Promise<boolean>;
        }>;
    };
    clearChatState(chatId: number, threadId?: string | null): void;
    handleAddServicePolicyNumber?(ctx: Context, numeroPoliza: string): Promise<void>;
}

class OcuparPolizaCallback extends BaseCommand {
    private awaitingPhoneNumber: IThreadSafeStateMap<string>;
    private awaitingOrigenDestino: IThreadSafeStateMap<string>;
    private awaitingOrigen: IThreadSafeStateMap<string>;
    private awaitingDestino: IThreadSafeStateMap<string>;
    private pendingLeyendas: IThreadSafeStateMap<string>;
    private polizaCache: IThreadSafeStateMap<any>;
    private messageIds: IThreadSafeStateMap<number>;
    private awaitingContactTime: IThreadSafeStateMap<string>;
    private scheduledServiceInfo: IThreadSafeStateMap<IScheduledServiceInfo>;
    private hereMapsService: HereMapsService;

    constructor(handler: IHandler) {
        super(handler);
        this.awaitingPhoneNumber = handler.awaitingPhoneNumber;
        this.awaitingOrigenDestino = handler.awaitingOrigenDestino;
        this.awaitingOrigen = handler.awaitingOrigen;
        this.awaitingDestino = handler.awaitingDestino;

        this.pendingLeyendas = StateKeyManager.createThreadSafeStateMap<string>();
        this.polizaCache = StateKeyManager.createThreadSafeStateMap<any>();
        this.messageIds = StateKeyManager.createThreadSafeStateMap<number>();
        this.awaitingContactTime = StateKeyManager.createThreadSafeStateMap<string>();
        this.scheduledServiceInfo =
            StateKeyManager.createThreadSafeStateMap<IScheduledServiceInfo>();

        this.hereMapsService = new HereMapsService();
    }

    getCommandName(): string {
        return 'ocuparPoliza';
    }

    getDescription(): string {
        return 'Manejador para ocupar una p√≥liza (asignar tel√©fono y origen-destino)';
    }

    register(): void {
        // Register the callback for "ocuparPoliza" button
        this.handler.registry.registerCallback(/ocuparPoliza:(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);
                logger.info(`[keepPhone] Iniciando callback para p√≥liza ${numeroPoliza}`, {
                    chatId,
                    threadId
                });

                const policy = (await getPolicyByNumber(numeroPoliza)) as IPolicy;
                if (!policy) {
                    await ctx.reply(`‚ùå P√≥liza ${numeroPoliza} no encontrada.`);
                    return;
                }

                this.polizaCache.set(
                    chatId,
                    {
                        numeroPoliza,
                        policy
                    },
                    threadId
                );

                if (policy.telefono) {
                    await ctx.reply(
                        `üì± ${policy.telefono}`,
                        Markup.inlineKeyboard([
                            [Markup.button.callback('üîÑ CAMBIAR', `changePhone:${numeroPoliza}`)],
                            [Markup.button.callback('‚úÖ MANTENER', `keepPhone:${numeroPoliza}`)]
                        ])
                    );

                    logger.info(`Mostrando opciones de tel√©fono para p√≥liza ${numeroPoliza}`, {
                        chatId,
                        threadId,
                        telefonoActual: policy.telefono
                    });
                } else {
                    const phoneSetResult = this.awaitingPhoneNumber.set(
                        chatId,
                        numeroPoliza,
                        threadId
                    );
                    logger.info(
                        `Estado de espera de tel√©fono guardado para nuevo tel√©fono: ${phoneSetResult ? 'OK' : 'FALLO'}`,
                        {
                            chatId,
                            threadId
                        }
                    );
                    const phoneHasResult = this.awaitingPhoneNumber.has(chatId, threadId);
                    logger.info(
                        `Verificaci√≥n inmediata de estado tel√©fono (nuevo): ${phoneHasResult ? 'OK' : 'FALLO'}`
                    );
                    await ctx.reply(
                        `üì± Ingresa el *n√∫mero telef√≥nico* (10 d√≠gitos) para la p√≥liza *${numeroPoliza}*.\n` +
                            '‚è±Ô∏è Si no respondes o ingresas comando en 1 min, se cancelar√°.',
                        { parse_mode: 'Markdown' }
                    );
                }

                logger.info(`Esperando tel√©fono para p√≥liza ${numeroPoliza}`, {
                    chatId: ctx.chat!.id,
                    threadId
                });
            } catch (error) {
                logger.error('Error en callback ocuparPoliza:', error);
                await ctx.reply('‚ùå Error al procesar ocupaci√≥n de p√≥liza.');
            } finally {
                await ctx.answerCbQuery();
            }
        });

        // Register callback for keeping existing phone number
        this.handler.registry.registerCallback(/keepPhone:(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('[keepPhone] Botones removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        '[keepPhone] No se pudo editar mensaje original:',
                        { error: (editError as Error).message }
                    );
                }

                const policy = (await getPolicyByNumber(numeroPoliza)) as IPolicy;
                if (!policy) {
                    await ctx.reply(`‚ùå P√≥liza ${numeroPoliza} no encontrada.`);
                    return;
                }

                logger.info('[keepPhone] Intentando eliminar estado awaitingPhoneNumber', {
                    chatId,
                    threadId
                });
                const deleteResult = this.awaitingPhoneNumber.delete(chatId, threadId);
                logger.info(
                    `[keepPhone] Resultado de delete awaitingPhoneNumber: ${deleteResult}`,
                    { chatId, threadId }
                );
                const hasAfterDelete = this.awaitingPhoneNumber.has(chatId, threadId);
                logger.info(
                    `[keepPhone] Verificaci√≥n inmediata awaitingPhoneNumber.has: ${hasAfterDelete}`,
                    { chatId, threadId }
                );

                logger.info('[keepPhone] Intentando establecer estado awaitingOrigen', {
                    chatId,
                    threadId
                });
                const setResult = this.awaitingOrigen.set(chatId, numeroPoliza, threadId);
                logger.info(`[keepPhone] Resultado de set awaitingOrigen: ${setResult}`, {
                    chatId,
                    threadId
                });
                const hasAfterSet = this.awaitingOrigen.has(chatId, threadId);
                logger.info(
                    `[keepPhone] Verificaci√≥n inmediata awaitingOrigen.has: ${hasAfterSet}`,
                    { chatId, threadId }
                );

                await ctx.reply(
                    `‚úÖ Se mantendr√° el n√∫mero: ${policy.telefono}\n\n` + 'üìçindica *ORIGEN*',
                    { parse_mode: 'Markdown' }
                );
            } catch (error) {
                logger.error('Error en callback keepPhone:', error);
                await ctx.reply('‚ùå Error al procesar la acci√≥n.');
            } finally {
                await ctx.answerCbQuery();
            }
        });

        // Register additional callbacks (abbreviated for brevity)
        this.registerChangePhoneCallback();
        this.registerServiceCallbacks();
        this.registerAssignmentCallbacks();
        this.registerDaySelectionCallbacks();
    }

    private registerChangePhoneCallback(): void {
        this.handler.registry.registerCallback(/changePhone:(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('[changePhone] Botones removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        '[changePhone] No se pudo editar mensaje original:',
                        { error: (editError as Error).message }
                    );
                }

                logger.info(
                    `[changePhone] Iniciando cambio de tel√©fono para p√≥liza ${numeroPoliza}`,
                    { chatId, threadId }
                );

                const phoneSetResult = this.awaitingPhoneNumber.set(chatId, numeroPoliza, threadId);
                logger.info(
                    `[changePhone] Estado de espera de tel√©fono guardado: ${phoneSetResult ? 'OK' : 'FALLO'}`,
                    {
                        chatId,
                        threadId
                    }
                );

                await ctx.reply(
                    `üì± Ingresa el *nuevo n√∫mero telef√≥nico* (10 d√≠gitos) para la p√≥liza *${numeroPoliza}*.\n` +
                        '‚è±Ô∏è Si no respondes o ingresas comando en 1 min, se cancelar√°.',
                    { parse_mode: 'Markdown' }
                );

                logger.info(`[changePhone] Esperando nuevo tel√©fono para p√≥liza ${numeroPoliza}`, {
                    chatId,
                    threadId
                });
            } catch (error) {
                logger.error('Error en callback changePhone:', error);
                await ctx.reply('‚ùå Error al procesar el cambio de tel√©fono.');
            } finally {
                await ctx.answerCbQuery();
            }
        });
    }

    private registerServiceCallbacks(): void {
        // Register callbacks for service-related actions
        this.handler.registry.registerCallback(/registrar_servicio_(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                logger.info(`Iniciando registro de servicio para p√≥liza: ${numeroPoliza}`, {
                    chatId,
                    threadId
                });

                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('Botones removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        'No se pudo editar mensaje original (probablemente ya fue editado):',
                        { error: (editError as Error).message }
                    );
                }

                // Obtener datos de la p√≥liza y geocoding para enviar leyenda azul de forma as√≠ncrona
                setImmediate(async () => {
                    try {
                        const threadIdStr = threadId ? String(threadId) : null;
                        const flowState = flowStateManager.getState(chatId, numeroPoliza, threadIdStr);
                        const policy = await getPolicyByNumber(numeroPoliza);
                        
                        if (flowState && policy && flowState.geocoding) {
                            const enhancedData = {
                                origenGeo: flowState.geocoding.origen,
                                destinoGeo: flowState.geocoding.destino,
                                googleMapsUrl: flowState.googleMapsUrl || flowState.rutaInfo?.googleMapsUrl,
                                leyenda: '' // No usado en la versi√≥n azul
                            };

                            const targetGroupId = -1002212807945;
                            logger.info(`Enviando leyenda azul al grupo ${targetGroupId} para registro de servicio`);
                            
                            // Enviar leyenda azul de forma as√≠ncrona y r√°pida
                            this.enviarLeyendaConEfectoTypingAzul(ctx.telegram, targetGroupId, policy, enhancedData).catch(error => {
                                logger.error('Error enviando leyenda azul:', error);
                            });
                        } else {
                            logger.warn('No se pudo obtener datos completos para leyenda azul', {
                                hasFlowState: !!flowState,
                                hasPolicy: !!policy,
                                hasGeocoding: !!(flowState?.geocoding)
                            });
                        }
                    } catch (error) {
                        logger.error('Error al obtener datos para leyenda azul:', error);
                    }
                });

                await ctx.reply('üöó **INGRESA EL N√öMERO DE EXPEDIENTE:**', {
                    parse_mode: 'Markdown'
                });

                (this.handler as any).awaitingServiceData.set(chatId, numeroPoliza, threadId);
                logger.info(
                    `Estado establecido para esperar datos del servicio para ${numeroPoliza}`
                );

            } catch (error) {
                logger.error('Error en callback registrarServicio:', error);
                await ctx.reply('‚ùå Error al iniciar el registro del servicio.');
            } finally {
                await ctx.answerCbQuery();
            }
        });

        this.handler.registry.registerCallback(/no_registrar_(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                logger.info(`No registrar servicio para p√≥liza: ${numeroPoliza}`, {
                    chatId,
                    threadId
                });

                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('Botones removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        'No se pudo editar mensaje original (probablemente ya fue editado):',
                        { error: (editError as Error).message }
                    );
                }

                await ctx.reply(
                    `‚úÖ Proceso finalizado para p√≥liza *${numeroPoliza}*.\n\n` +
                        'üìù Los datos de origen-destino y tel√©fono han sido guardados.\n' +
                        'üö´ No se registrar√° ning√∫n servicio en este momento.',
                    { parse_mode: 'Markdown' }
                );

                const threadIdStr = threadId ? String(threadId) : null;
                this.cleanupAllStates(chatId, threadIdStr);
            } catch (error) {
                logger.error('Error en callback noRegistrar:', error);
                await ctx.reply('‚ùå Error al finalizar el proceso.');
            } finally {
                await ctx.answerCbQuery();
            }
        });
    }

    private registerAssignmentCallbacks(): void {
        // Register callback for "Asignado" button
        this.handler.registry.registerCallback(/asig_yes_(.+)_(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const numeroRegistro = parseInt((ctx.match as RegExpMatchArray)[2]);
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                // PROTECCI√ìN ANTI-DOBLE-CLIC: Verificar si ya se est√° procesando
                const processingKey = `${chatId}_${numeroPoliza}_${numeroRegistro}`;
                if (
                    (this.handler as any).processingCallbacks &&
                    (this.handler as any).processingCallbacks.has(processingKey)
                ) {
                    logger.warn(
                        `[ANTI-DUPLICATE] Callback asig_yes ya proces√°ndose para ${processingKey}, ignorando`
                    );
                    await ctx.answerCbQuery('‚ö†Ô∏è Procesando... espera un momento');
                    return;
                }

                // Marcar como proces√°ndose
                if (!(this.handler as any).processingCallbacks) {
                    (this.handler as any).processingCallbacks = new Set();
                }
                (this.handler as any).processingCallbacks.add(processingKey);

                logger.info(
                    `Registro ${numeroRegistro} marcado como ASIGNADO para p√≥liza: ${numeroPoliza}`,
                    { chatId, threadId }
                );

                // Edit the original message to remove buttons
                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('Botones ASIGNADO/NO ASIGNADO removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        'No se pudo editar mensaje original (probablemente ya fue editado):',
                        { error: (editError as Error).message }
                    );
                }

                // Obtener la p√≥liza para extraer datos del registro
                const policy = await getPolicyByNumber(numeroPoliza) as IPolicy;
                if (!policy) {
                    await ctx.reply(`‚ùå P√≥liza ${numeroPoliza} no encontrada.`);
                    return;
                }

                // Buscar el registro espec√≠fico
                const registro = policy.registros.find((r: any) => r.numeroRegistro === numeroRegistro);
                if (!registro) {
                    await ctx.reply(
                        `‚ùå Registro ${numeroRegistro} no encontrado en p√≥liza ${numeroPoliza}.`
                    );
                    return;
                }

                // Calcular horas autom√°ticas (fecha base = ahora)
                const fechaBase = new Date();
                const tiempoTrayecto = registro.rutaInfo?.tiempoMinutos || 0;
                const horasCalculadas = calcularHorasAutomaticas(fechaBase, tiempoTrayecto);

                logger.info('Horas calculadas autom√°ticamente:', {
                    contacto: horasCalculadas.fechaContactoProgramada,
                    termino: horasCalculadas.fechaTerminoProgramada,
                    minutosContacto: horasCalculadas.minutosContacto,
                    minutosTermino: horasCalculadas.minutosTermino
                });

                // Convertir registro a servicio confirmado
                const resultado = await convertirRegistroAServicio(
                    numeroPoliza,
                    numeroRegistro,
                    horasCalculadas.fechaContactoProgramada,
                    horasCalculadas.fechaTerminoProgramada
                );

                if (!resultado) {
                    await ctx.reply(`‚ùå Error al convertir registro ${numeroRegistro} a servicio.`);
                    return;
                }

                const { numeroServicio } = resultado;

                // Formatear fechas para mostrar
                const fechaContactoStr = horasCalculadas.fechaContactoProgramada.toLocaleString(
                    'es-MX',
                    {
                        timeZone: 'America/Mexico_City',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }
                );

                const fechaTerminoStr = horasCalculadas.fechaTerminoProgramada.toLocaleString(
                    'es-MX',
                    {
                        timeZone: 'America/Mexico_City',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }
                );

                // Confirmar conversi√≥n con detalles autom√°ticos
                await ctx.reply(
                    `‚úÖ *Registro convertido a Servicio #${numeroServicio}*\n\n` +
                        '‚ú®Los c√°lculos fueron realizados‚ú®\n\n' +
                        '‚è∞ *Programaci√≥n:*\n' +
                        `üìû Contacto: ${fechaContactoStr}\n` +
                        `üèÅ T√©rmino: ${fechaTerminoStr}\n\n` +
                        'ü§ñ Las notificaciones se enviar√°n autom√°ticamente.',
                    { parse_mode: 'Markdown' }
                );

                // Programar notificaciones autom√°ticas usando el sistema existente
                try {
                    const notificationManager = getInstance();

                    if (!notificationManager || !notificationManager.isInitialized) {
                        logger.error(
                            'NotificationManager no est√° inicializado para notificaciones autom√°ticas'
                        );
                    } else {
                        // Formatear horas para notificaciones (HH:mm formato)
                        const contactTimeStr =
                            horasCalculadas.fechaContactoProgramada.toLocaleTimeString('es-MX', {
                                timeZone: 'America/Mexico_City',
                                hour12: false,
                                hour: '2-digit',
                                minute: '2-digit'
                            });

                        const terminoTimeStr =
                            horasCalculadas.fechaTerminoProgramada.toLocaleTimeString('es-MX', {
                                timeZone: 'America/Mexico_City',
                                hour12: false,
                                hour: '2-digit',
                                minute: '2-digit'
                            });

                        // Obtener datos del registro para notificaciones
                        const origenDestino = registro.origenDestino || 'Origen - Destino';
                        const marcaModelo = `${policy.marca} ${policy.submarca} (${policy.a√±o})`;

                        logger.info('Programando notificaciones autom√°ticas:', {
                            expediente: registro.numeroExpediente,
                            contacto: contactTimeStr,
                            termino: terminoTimeStr,
                            fechaContacto: horasCalculadas.fechaContactoProgramada.toISOString(),
                            fechaTermino: horasCalculadas.fechaTerminoProgramada.toISOString()
                        });

                        // PROGRAMACI√ìN SECUENCIAL DE NOTIFICACIONES (ANTI-DUPLICADOS)
                        const results: Array<
                            { status: 'fulfilled'; value: any } | { status: 'rejected'; reason: any }
                        > = [{ status: 'rejected', reason: null }, { status: 'rejected', reason: null }];

                        try {
                            // 1. Programar notificaci√≥n de CONTACTO primero
                            const notifContacto = await notificationManager.scheduleNotification({
                                numeroPoliza: numeroPoliza,
                                targetGroupId: -1002212807945,
                                contactTime: contactTimeStr,
                                expedienteNum: registro.numeroExpediente,
                                origenDestino: origenDestino,
                                marcaModelo: marcaModelo,
                                colorVehiculo: policy.color,
                                placas: policy.placas,
                                telefono: policy.telefono,
                                scheduledDate: horasCalculadas.fechaContactoProgramada,
                                tipoNotificacion: 'CONTACTO'
                            });
                            results[0] = { status: 'fulfilled', value: notifContacto };
                        } catch (contactoError) {
                            results[0] = { status: 'rejected', reason: contactoError };
                            logger.error(
                                'Error programando notificaci√≥n de CONTACTO:',
                                contactoError
                            );
                        }

                        try {
                            // 2. Programar notificaci√≥n de T√âRMINO despu√©s
                            const notifTermino = await notificationManager.scheduleNotification({
                                numeroPoliza: numeroPoliza,
                                targetGroupId: -1002212807945,
                                contactTime: terminoTimeStr,
                                expedienteNum: registro.numeroExpediente,
                                origenDestino: origenDestino,
                                marcaModelo: marcaModelo,
                                colorVehiculo: policy.color,
                                placas: policy.placas,
                                telefono: policy.telefono,
                                scheduledDate: horasCalculadas.fechaTerminoProgramada,
                                tipoNotificacion: 'TERMINO'
                            });
                            results[1] = { status: 'fulfilled', value: notifTermino };
                        } catch (terminoError) {
                            results[1] = { status: 'rejected', reason: terminoError };
                            logger.error(
                                'Error programando notificaci√≥n de T√âRMINO:',
                                terminoError
                            );
                        }

                        // Procesar resultados
                        const notificationContacto =
                            results[0].status === 'fulfilled' ? results[0].value : null;
                        const notificationTermino =
                            results[1].status === 'fulfilled' ? results[1].value : null;

                        if (notificationContacto) {
                            logger.info(
                                `‚úÖ Notificaci√≥n de CONTACTO programada ID: ${notificationContacto._id} para ${contactTimeStr}`
                            );
                        } else {
                            logger.error(
                                'Error programando notificaci√≥n de CONTACTO:',
                                results[0].status === 'rejected' ? results[0].reason : 'Error desconocido'
                            );
                        }

                        if (notificationTermino) {
                            logger.info(
                                `‚úÖ Notificaci√≥n de T√âRMINO programada ID: ${notificationTermino._id} para ${terminoTimeStr}`
                            );
                        } else {
                            logger.error(
                                'Error programando notificaci√≥n de T√âRMINO:',
                                results[1].status === 'rejected' ? results[1].reason : 'Error desconocido'
                            );
                        }

                        // Validar que al menos una notificaci√≥n se haya programado exitosamente
                        if (!notificationContacto && !notificationTermino) {
                            throw new Error('No se pudo programar ninguna notificaci√≥n autom√°tica');
                        }
                    }
                } catch (notifyError) {
                    logger.error('Error al programar notificaciones autom√°ticas:', notifyError);
                    // Continuar a pesar del error, no es cr√≠tico para el flujo principal
                }

                logger.info(
                    `Servicio #${numeroServicio} confirmado y programado para p√≥liza ${numeroPoliza}`
                );
            } catch (error) {
                logger.error('Error en callback assignedService:', error);
                await ctx.reply('‚ùå Error al procesar la asignaci√≥n del servicio.');
                const threadId = StateKeyManager.getThreadId(ctx);
                const threadIdStr = threadId ? String(threadId) : null;
                this.cleanupAllStates(ctx.chat!.id, threadIdStr);
            } finally {
                // LIMPIAR ESTADO DE PROCESAMIENTO
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const numeroRegistro = parseInt((ctx.match as RegExpMatchArray)[2]);
                const processingKey = `${ctx.chat!.id}_${numeroPoliza}_${numeroRegistro}`;
                if ((this.handler as any).processingCallbacks) {
                    (this.handler as any).processingCallbacks.delete(processingKey);
                    logger.info(
                        `[ANTI-DUPLICATE] Estado de procesamiento limpiado para ${processingKey}`
                    );
                }
                await ctx.answerCbQuery();
            }
        });

        // Register callback for "No asignado" button
        this.handler.registry.registerCallback(/asig_no_(.+)_(.+)/, async (ctx: Context) => {
            try {
                const numeroPoliza = (ctx.match as RegExpMatchArray)[1];
                const numeroRegistro = parseInt((ctx.match as RegExpMatchArray)[2]);
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                logger.info(
                    `Registro ${numeroRegistro} marcado como NO ASIGNADO para p√≥liza: ${numeroPoliza}`,
                    { chatId, threadId }
                );

                // Edit the original message to remove buttons
                try {
                    await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
                    logger.info('Botones ASIGNADO/NO ASIGNADO removidos del mensaje original');
                } catch (editError) {
                    logger.info(
                        'No se pudo editar mensaje original (probablemente ya fue editado):',
                        { error: (editError as Error).message }
                    );
                }

                // Marcar registro como no asignado en la base de datos
                const resultado = await marcarRegistroNoAsignado(numeroPoliza, numeroRegistro);

                if (resultado) {
                    await ctx.reply(
                        `‚úÖ Registro ${numeroRegistro} marcado como *NO ASIGNADO* para p√≥liza ${numeroPoliza}.\n\n` +
                            'üìù El registro permanecer√° en la base de datos pero no se programar√° ning√∫n servicio.',
                        { parse_mode: 'Markdown' }
                    );
                } else {
                    await ctx.reply(
                        `‚ùå Error al marcar registro ${numeroRegistro} como NO ASIGNADO.`
                    );
                }

                logger.info(
                    `Registro ${numeroRegistro} procesado como NO ASIGNADO para p√≥liza ${numeroPoliza}`
                );
            } catch (error) {
                logger.error('Error en callback noAssignedService:', error);
                await ctx.reply('‚ùå Error al procesar la NO asignaci√≥n del servicio.');
            } finally {
                await ctx.answerCbQuery();
            }
        });
    }

    private registerDaySelectionCallbacks(): void {
        this.handler.registry.registerCallback(/selectDay:(\d+):(.+)/, async (ctx: Context) => {
            try {
                const daysOffset = parseInt((ctx.match as RegExpMatchArray)[1], 10);
                const numeroPoliza = (ctx.match as RegExpMatchArray)[2];
                const chatId = ctx.chat!.id;
                const threadId = StateKeyManager.getThreadId(ctx);

                logger.info(`Selecci√≥n de d√≠a: offset=${daysOffset}, p√≥liza=${numeroPoliza}`, {
                    chatId,
                    threadId
                });

                await ctx.answerCbQuery();

                const serviceInfo = this.scheduledServiceInfo.get(chatId, threadId);
                if (!serviceInfo?.contactTime) {
                    logger.error('No se encontr√≥ info de servicio o falta hora de contacto');
                    await ctx.reply(
                        '‚ùå Error: No se encontr√≥ la informaci√≥n de la hora de contacto.'
                    );
                    return;
                }

                logger.info(
                    `Recuperada info de servicio: contactTime=${serviceInfo.contactTime}, origen=${serviceInfo.origin}, destino=${serviceInfo.destination}`
                );

                const moment = require('moment-timezone');
                const today = moment().tz('America/Mexico_City');
                const scheduledMoment = today.clone().add(daysOffset, 'days');

                const [hours, minutes] = serviceInfo.contactTime.split(':').map(Number);
                scheduledMoment.hour(hours).minute(minutes).second(0).millisecond(0);

                const scheduledDateJS = scheduledMoment.toDate();
                serviceInfo.scheduledDate = scheduledDateJS;
                const serviceStore = this.scheduledServiceInfo.set(chatId, serviceInfo, threadId);

                logger.info(
                    `Info de servicio actualizada con fecha=${scheduledMoment.format()}: ${serviceStore ? 'OK' : 'FALLO'}`
                );

                const dayNames = [
                    'Domingo',
                    'Lunes',
                    'Martes',
                    'Mi√©rcoles',
                    'Jueves',
                    'Viernes',
                    'S√°bado'
                ];
                const dayName = dayNames[scheduledMoment.day()];
                const dateStr = scheduledMoment.format('DD/MM/YYYY');

                await ctx.editMessageText(
                    `‚úÖ Alerta programada para: *${dayName}, ${dateStr} a las ${serviceInfo.contactTime}*\n\n` +
                        'El servicio ha sido registrado correctamente. No se requieren m√°s acciones.',
                    {
                        parse_mode: 'Markdown'
                    }
                );

                logger.info(
                    `Limpiando estados para chatId=${chatId}, threadId=${threadId} despu√©s de completar flujo.`
                );
                const threadIdStr = threadId ? String(threadId) : null;
                this.cleanupAllStates(chatId, threadIdStr);
            } catch (error) {
                logger.error('Error al procesar selecci√≥n de d√≠a:', error);
                await ctx.reply('‚ùå Error al procesar la selecci√≥n de d√≠a. Operaci√≥n cancelada.');
                const threadId = StateKeyManager.getThreadId(ctx);
                const threadIdStr = threadId ? String(threadId) : null;
                this.cleanupAllStates(ctx.chat!.id, threadIdStr);
            }
        });
    }

    async handlePhoneNumber(
        ctx: Context,
        messageText: string,
        threadId: string | null = null
    ): Promise<boolean> {
        const chatId = ctx.chat!.id;
        const numeroPoliza = this.awaitingPhoneNumber.get(chatId, threadId);

        const regexTel = /^\d{10}$/;
        if (!regexTel.test(messageText)) {
            this.awaitingPhoneNumber.delete(chatId, threadId);
            await ctx.reply('‚ùå Tel√©fono inv√°lido (requiere 10 d√≠gitos). Proceso cancelado.');
            return true;
        }

        try {
            let policy: IPolicy;
            const cachedData = this.polizaCache.get(chatId, threadId);

            if (cachedData && cachedData.numeroPoliza === numeroPoliza) {
                policy = cachedData.policy;
            } else {
                if (!numeroPoliza) {
                    logger.error(`N√∫mero de p√≥liza no encontrado en handlePhoneNumber`);
                    this.awaitingPhoneNumber.delete(chatId, threadId);
                    await ctx.reply('‚ùå Error: N√∫mero de p√≥liza no encontrado. Operaci√≥n cancelada.');
                    return true;
                }
                policy = (await getPolicyByNumber(numeroPoliza)) as IPolicy;
            }

            if (!policy) {
                logger.error(`P√≥liza no encontrada en handlePhoneNumber: ${numeroPoliza}`);
                this.awaitingPhoneNumber.delete(chatId, threadId);
                await ctx.reply(
                    `‚ùå Error: P√≥liza ${numeroPoliza} no encontrada. Operaci√≥n cancelada.`
                );
                return true;
            }

            policy.telefono = messageText;
            await policy.save();

            if (cachedData) {
                cachedData.policy = policy;
                this.polizaCache.set(chatId, cachedData, threadId);
            }

            await ctx.reply(
                `‚úÖ Tel√©fono ${messageText} asignado a la p√≥liza ${numeroPoliza}.\n\n` +
                    'üìçindica *ORIGEN*',
                { parse_mode: 'Markdown' }
            );

            this.awaitingPhoneNumber.delete(chatId, threadId);

            const origenResult = this.awaitingOrigen.set(chatId, numeroPoliza || '', threadId);
            logger.info(`Estado de espera de origen guardado: ${origenResult ? 'OK' : 'FALLO'}`, {
                chatId,
                threadId: threadId || 'ninguno'
            });

            const origenHasResult = this.awaitingOrigen.has(chatId, threadId);
            logger.info(
                `Verificaci√≥n inmediata de estado origen-destino: ${origenHasResult ? 'OK' : 'FALLO'}`
            );

            return true;
        } catch (error) {
            logger.error(`Error guardando tel√©fono para p√≥liza ${numeroPoliza}:`, error);
            this.awaitingPhoneNumber.delete(chatId, threadId);
            await ctx.reply('‚ùå Error al guardar el tel√©fono. Operaci√≥n cancelada.');
            return true;
        }
    }

    async handleOrigen(ctx: Context, input: any, threadId: string | null = null): Promise<boolean> {
        const chatId = ctx.chat!.id;
        const numeroPoliza = this.awaitingOrigen.get(chatId, threadId);

        if (!numeroPoliza) {
            logger.error('No se encontr√≥ n√∫mero de p√≥liza para origen');
            return false;
        }

        logger.info(`Procesando ubicaci√≥n de origen para p√≥liza ${numeroPoliza}`, {
            chatId,
            threadId: threadId || 'ninguno',
            inputType: typeof input === 'object' ? 'location' : 'text'
        });

        try {
            let coordenadas = null;

            if (input?.location) {
                coordenadas = {
                    lat: input.location.latitude,
                    lng: input.location.longitude
                };
                logger.info(
                    'Coordenadas de origen extra√≠das de ubicaci√≥n de Telegram',
                    coordenadas
                );
            } else if (typeof input === 'string') {
                coordenadas = this.hereMapsService.parseCoordinates(input);
                if (!coordenadas) {
                    await ctx.reply('‚ùå Formato inv√°lido. üìçindica *ORIGEN*', {
                        parse_mode: 'Markdown'
                    });
                    return false;
                }
                logger.info('Coordenadas de origen extra√≠das de texto', coordenadas);
            } else {
                await ctx.reply('‚ùå Formato de entrada no v√°lido para el origen.');
                return false;
            }

            // Guardar coordenadas de origen en FlowStateManager
            flowStateManager.saveState(chatId, numeroPoliza, { origenCoords: coordenadas }, threadId);

            // Tambi√©n almacenar en cach√© local para compatibilidad
            const cachedData = this.polizaCache.get(chatId, threadId);
            if (cachedData) {
                cachedData.origenCoords = coordenadas;
                this.polizaCache.set(chatId, cachedData, threadId);
            }

            this.awaitingOrigen.delete(chatId, threadId);
            this.awaitingDestino.set(chatId, numeroPoliza, threadId);

            await ctx.reply(
                `‚úÖ Origen registrado: ${coordenadas.lat}, ${coordenadas.lng}\n\n` +
                    'üìçindica *DESTINO*',
                { parse_mode: 'Markdown' }
            );

            return true;
        } catch (error) {
            logger.error('Error procesando origen:', error);
            await ctx.reply('‚ùå Error al procesar la ubicaci√≥n del origen.');
            return false;
        }
    }

    async handleDestino(
        ctx: Context,
        input: any,
        threadId: string | null = null
    ): Promise<boolean> {
        const chatId = ctx.chat!.id;
        const numeroPoliza = this.awaitingDestino.get(chatId, threadId);

        if (!numeroPoliza) {
            logger.error('No se encontr√≥ n√∫mero de p√≥liza para destino');
            return false;
        }

        logger.info(`Procesando ubicaci√≥n de destino para p√≥liza ${numeroPoliza}`, {
            chatId,
            threadId: threadId || 'ninguno',
            inputType: typeof input === 'object' ? 'location' : 'text'
        });

        try {
            let coordenadas = null;

            if (input && input.location) {
                coordenadas = {
                    lat: input.location.latitude,
                    lng: input.location.longitude
                };
                logger.info('Coordenadas de destino extra√≠das de ubicaci√≥n de Telegram', coordenadas);
            } else if (typeof input === 'string') {
                coordenadas = this.hereMapsService.parseCoordinates(input);
                if (!coordenadas) {
                    await ctx.reply('‚ùå Formato inv√°lido. üìçindica *DESTINO*', {
                        parse_mode: 'Markdown'
                    });
                    return false;
                }
                logger.info('Coordenadas de destino extra√≠das de texto', coordenadas);
            } else {
                await ctx.reply('‚ùå Formato de entrada no v√°lido para el destino.');
                return false;
            }

            // Recuperar coordenadas de origen desde FlowStateManager
            const threadIdStr = threadId ? String(threadId) : null;
            const savedState = flowStateManager.getState(chatId, numeroPoliza, threadIdStr);
            const origenCoords = savedState?.origenCoords;

            if (!origenCoords) {
                logger.error('No se encontraron coordenadas de origen guardadas');
                await ctx.reply('‚ùå Error: No se encontraron las coordenadas del origen. Reinicia el proceso.');
                this.awaitingDestino.delete(chatId, threadId);
                return false;
            }

            // Calcular ruta con HERE Maps API
            logger.info('Calculando ruta con HERE Maps API');
            const rutaInfo = await this.hereMapsService.calculateRoute(origenCoords, coordenadas);

            // Obtener p√≥liza desde cach√© o BD
            const policyCacheData = this.polizaCache.get(chatId, threadId);
            const policy = policyCacheData?.policy || (await getPolicyByNumber(numeroPoliza)) as IPolicy;
            if (!policy) {
                await ctx.reply('‚ùå Error: P√≥liza no encontrada.');
                this.awaitingDestino.delete(chatId, threadId);
                return false;
            }

            // Generar leyenda mejorada con geocoding
            const enhancedData = await this.generateEnhancedLegend(
                policy,
                origenCoords,
                coordenadas,
                rutaInfo
            );
            const leyenda = enhancedData.leyenda;

            // Guardar datos completos en FlowStateManager
            const saveData: any = {
                origenCoords,
                destinoCoords: coordenadas,
                coordenadas: {
                    origen: origenCoords,
                    destino: coordenadas
                },
                rutaInfo,
                origenDestino: `${origenCoords.lat},${origenCoords.lng} - ${coordenadas.lat},${coordenadas.lng}`
            };

            // Agregar informaci√≥n de geocoding si est√° disponible
            if (enhancedData) {
                saveData.geocoding = {
                    origen: enhancedData.origenGeo,
                    destino: enhancedData.destinoGeo
                };
                saveData.googleMapsUrl = enhancedData.googleMapsUrl;
                saveData.origenDestino = `${enhancedData.origenGeo.ubicacionCorta} - ${enhancedData.destinoGeo.ubicacionCorta}`;
            }

            flowStateManager.saveState(chatId, numeroPoliza, saveData, threadId);

            // Actualizar cach√© de p√≥liza
            if (policyCacheData) {
                policyCacheData.destinoCoords = coordenadas;
                policyCacheData.coordenadas = { origen: origenCoords, destino: coordenadas };
                policyCacheData.rutaInfo = rutaInfo;
                this.polizaCache.set(chatId, policyCacheData, threadId);
            }

            // Guardar leyenda para env√≠o
            this.pendingLeyendas.set(chatId, leyenda, threadId);

            // Crear mensaje de respuesta con info de ruta
            let responseMessage = `‚úÖ Destino registrado: ${coordenadas.lat}, ${coordenadas.lng}\n\n`;

            if (rutaInfo) {
                responseMessage +=
                    'üó∫Ô∏è *Informaci√≥n de ruta:*\n' +
                    `üìè Distancia: ${rutaInfo.distanciaKm} km\n` +
                    `‚è±Ô∏è Tiempo estimado: ${rutaInfo.tiempoMinutos} minutos`;
                if (rutaInfo.aproximado) {
                    responseMessage += ' (aproximado)';
                }
                responseMessage += `\nüîó [Ver ruta en Google Maps](${rutaInfo.googleMapsUrl})\n\n`;
            }

            // Env√≠o autom√°tico de leyenda al grupo con efecto typing (as√≠ncrono)
            const targetGroupId = -1002212807945;

            // Enviar leyenda en background sin bloquear al usuario
            setImmediate(async () => {
                try {
                    logger.info(`Enviando leyenda autom√°ticamente al grupo ${targetGroupId} con efecto typing`);
                    await this.enviarLeyendaConEfectoTyping(ctx.telegram, targetGroupId, policy, enhancedData);
                    logger.info(`Leyenda con efecto typing enviada al grupo: ${targetGroupId}`);
                } catch (sendError) {
                    logger.error('Error al enviar leyenda autom√°ticamente al grupo:', sendError);
                }
            });

            // Enviar mensaje de confirmaci√≥n con opciones de servicio inmediatamente
            await ctx.reply(
                responseMessage +
                    '‚úÖ *Leyenda enviada al grupo de servicios.*\n\n' +
                    'üöó ¬øDeseas registrar un servicio?',
                {
                    parse_mode: 'Markdown',
                    link_preview_options: { is_disabled: true },
                    ...Markup.inlineKeyboard([
                        [
                            Markup.button.callback('‚úÖ Registrar Servicio', `registrar_servicio_${numeroPoliza}`),
                            Markup.button.callback('‚ùå No registrar', `no_registrar_${numeroPoliza}`)
                        ]
                    ])
                }
            );

            logger.info('Flujo autom√°tico completado - respuesta inmediata al usuario');

            // Limpieza de estados
            this.pendingLeyendas.delete(chatId, threadId);
            this.awaitingDestino.delete(chatId, threadId);
            return true;

        } catch (error) {
            logger.error('Error procesando destino:', error);
            await ctx.reply('‚ùå Error al procesar la ubicaci√≥n del destino.');
            this.awaitingDestino.delete(chatId, threadId);
            return false;
        }
    }

    async generateEnhancedLegend(
        policy: IPolicy,
        origenCoords: { lat: number; lng: number },
        destinoCoords: { lat: number; lng: number },
        rutaInfo: any
    ): Promise<{
        leyenda: string;
        origenGeo: any;
        destinoGeo: any;
        googleMapsUrl: string;
    }> {
        try {
            // Realizar geocoding reverso para origen y destino
            const [origenGeo, destinoGeo] = await Promise.all([
                this.hereMapsService.reverseGeocode(origenCoords.lat, origenCoords.lng),
                this.hereMapsService.reverseGeocode(destinoCoords.lat, destinoCoords.lng)
            ]);

            // Generar URL de Google Maps
            const googleMapsUrl = this.hereMapsService.generateGoogleMapsUrl(
                origenCoords,
                destinoCoords
            );

            // Formato de ubicaci√≥n simplificado: "Colonia - Municipio"
            const origenTexto = origenGeo.ubicacionCorta.toUpperCase();
            const destinoTexto = destinoGeo.ubicacionCorta.toUpperCase();

            // Nuevo formato de leyenda con dise√±o visual llamativo
            const leyenda =
                '‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è\n' +
                `üî• A L E R T A.    ${policy.aseguradora} üî•\n` +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ\n\n' +
                `üöó ${policy.marca} - ${policy.submarca} - ${policy.a√±o}\n\n` +
                `üî∏ ORIGEN: ${origenTexto}\n` +
                `üî∏ DESTINO: ${destinoTexto}\n\n` +
                `üó∫Ô∏è ${googleMapsUrl}\n\n` +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ\n' +
                'üåü S E R V I C I O     A C T I V O üåü\n' +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ';

            logger.info(`Nueva leyenda generada: ${leyenda}`);

            return {
                leyenda,
                origenGeo,
                destinoGeo,
                googleMapsUrl
            };
        } catch (error) {
            logger.error('Error generando leyenda mejorada:', error);

            // Fallback: usar coordenadas directas con dise√±o visual llamativo
            const googleMapsUrl = this.hereMapsService.generateGoogleMapsUrl(
                origenCoords,
                destinoCoords
            );
            const leyenda =
                '‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è‚ö°Ô∏è\n' +
                `üî• A L E R T A.    ${policy.aseguradora} üî•\n` +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ\n\n' +
                `üöó ${policy.marca} - ${policy.submarca} - ${policy.a√±o}\n\n` +
                `üî∏ ORIGEN: ${origenCoords.lat.toFixed(4)}, ${origenCoords.lng.toFixed(4)}\n` +
                `üî∏ DESTINO: ${destinoCoords.lat.toFixed(4)}, ${destinoCoords.lng.toFixed(4)}\n\n` +
                `üó∫Ô∏è ${googleMapsUrl}\n\n` +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ\n' +
                'üåü S E R V I C I O     A C T I V O üåü\n' +
                'üöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄüöÄ';

            return {
                leyenda,
                origenGeo: {
                    ubicacionCorta: `${origenCoords.lat.toFixed(4)}, ${origenCoords.lng.toFixed(4)}`,
                    fallback: true
                },
                destinoGeo: {
                    ubicacionCorta: `${destinoCoords.lat.toFixed(4)}, ${destinoCoords.lng.toFixed(4)}`,
                    fallback: true
                },
                googleMapsUrl
            };
        }
    }

    /**
     * Env√≠a una leyenda al grupo con efecto typing usando m√∫ltiples mensajes secuenciales
     */
    async enviarLeyendaConEfectoTyping(
        telegram: any,
        targetGroupId: number,
        policy: any,
        enhancedData: any
    ): Promise<void> {
        try {
            const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

            // Secuencia de mensajes para crear efecto typing
            const mensajes = [
                'üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£',
                'üî• PENDIENTES',
                `üî• **ALERTA ${policy.aseguradora}**`,
                `üî• **${policy.marca} - ${policy.submarca} - ${policy.a√±o}**`,
                `üî• ORIGEN: ${enhancedData.origenGeo.ubicacionCorta.toUpperCase()}`,
                `üî• DESTINO: ${enhancedData.destinoGeo.ubicacionCorta.toUpperCase()}`
            ];

            // Enviar cada mensaje con delay
            for (let i = 0; i < mensajes.length; i++) {
                await telegram.sendMessage(targetGroupId, mensajes[i], { parse_mode: 'Markdown' });
                logger.info(`Mensaje ${i + 1}/${mensajes.length} enviado: ${mensajes[i]}`);
                
                // Delay entre mensajes (menos en el √∫ltimo) - 4 mensajes por segundo
                if (i < mensajes.length - 1) {
                    await delay(250); // 250ms entre mensajes = 4 por segundo
                }
            }

            // Mensaje con URL de Google Maps
            const mensajeUrl = `üó∫Ô∏è ${enhancedData.googleMapsUrl}`;

            await delay(250); // Delay antes del mensaje con URL - 4 por segundo
            await telegram.sendMessage(targetGroupId, mensajeUrl);
            
            await delay(250); // Delay antes del mensaje de cierre - 4 por segundo
            
            // Mensaje de cierre morado separado
            const mensajeCierre = 'üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£üü£';
            await telegram.sendMessage(targetGroupId, mensajeCierre);
            
            logger.info('Secuencia de leyenda con efecto typing completada exitosamente');
            
        } catch (error) {
            logger.error('Error enviando leyenda con efecto typing:', error);
            
            // Fallback: enviar leyenda original en caso de error
            const leyendaFallback = enhancedData.leyenda;
            await telegram.sendMessage(targetGroupId, leyendaFallback);
            logger.info('Enviada leyenda fallback por error en efecto typing');
        }
    }

    /**
     * Env√≠a una leyenda al grupo con efecto typing usando m√∫ltiples mensajes secuenciales (versi√≥n azul para registro de servicio)
     */
    async enviarLeyendaConEfectoTypingAzul(
        telegram: any,
        targetGroupId: number,
        policy: any,
        enhancedData: any
    ): Promise<void> {
        try {
            const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

            // Secuencia de mensajes para crear efecto typing en azul
            const mensajes = [
                'üîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµ',
                'üî• PENDIENTES',
                `üî• **ALERTA ${policy.aseguradora}**`,
                `üî• **${policy.marca} - ${policy.submarca} - ${policy.a√±o}**`,
                `üî• ORIGEN: ${enhancedData.origenGeo.ubicacionCorta.toUpperCase()}`,
                `üî• DESTINO: ${enhancedData.destinoGeo.ubicacionCorta.toUpperCase()}`
            ];

            // Enviar cada mensaje con delay
            for (let i = 0; i < mensajes.length; i++) {
                await telegram.sendMessage(targetGroupId, mensajes[i], { parse_mode: 'Markdown' });
                logger.info(`Mensaje azul ${i + 1}/${mensajes.length} enviado: ${mensajes[i]}`);
                
                // Delay entre mensajes azules - mismo ritmo que morado (4 por segundo)
                if (i < mensajes.length - 1) {
                    await delay(250); // 250ms entre mensajes = 4 por segundo
                }
            }

            // Mensaje con URL de Google Maps
            const mensajeUrl = `üó∫Ô∏è ${enhancedData.googleMapsUrl}`;

            await delay(250); // Delay antes del mensaje con URL azul - 4 por segundo
            await telegram.sendMessage(targetGroupId, mensajeUrl);
            
            await delay(250); // Delay antes del mensaje de cierre azul - 4 por segundo
            
            // Mensaje de cierre azul separado
            const mensajeCierre = 'üîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµ';
            await telegram.sendMessage(targetGroupId, mensajeCierre);
            
            logger.info('Secuencia de leyenda azul con efecto typing completada exitosamente');
            
        } catch (error) {
            logger.error('Error enviando leyenda azul con efecto typing:', error);
            
            // Fallback: enviar leyenda original en caso de error
            const leyendaFallback = enhancedData.leyenda;
            await telegram.sendMessage(targetGroupId, leyendaFallback);
            logger.info('Enviada leyenda fallback por error en efecto typing azul');
        }
    }

    async handleContactTime(
        ctx: Context,
        messageText: string,
        threadId: string | null = null
    ): Promise<boolean> {
        const chatId = ctx.chat!.id;
        const numeroPoliza = this.awaitingContactTime.get(chatId, threadId);

        logger.info(`Procesando hora de contacto: ${messageText} para p√≥liza: ${numeroPoliza}`, {
            chatId,
            threadId
        });

        const timeRegex = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
        if (!timeRegex.test(messageText)) {
            await ctx.reply(
                '‚ö†Ô∏è Formato de hora inv√°lido. Debe ser HH:mm (24 horas).\n' +
                    'Ejemplos v√°lidos: 09:30, 14:45, 23:15'
            );
            return false;
        }

        try {
            const serviceInfo = this.scheduledServiceInfo.get(chatId, threadId);
            if (!serviceInfo) {
                logger.error(`No se encontr√≥ info de servicio para p√≥liza: ${numeroPoliza}`);
                this.awaitingContactTime.delete(chatId, threadId);
                await ctx.reply('‚ùå Error al procesar la hora. Operaci√≥n cancelada.');
                return false;
            }

            if (!serviceInfo.expediente) {
                logger.info(
                    'No se encontr√≥ expediente para la notificaci√≥n, generando uno gen√©rico'
                );
                serviceInfo.expediente = `EXP-${new Date().toISOString().slice(0, 10)}`;
            }

            serviceInfo.contactTime = messageText;
            const serviceStore = this.scheduledServiceInfo.set(chatId, serviceInfo, threadId);
            logger.info(
                `Info de servicio actualizada con hora=${messageText}: ${serviceStore ? 'OK' : 'FALLO'}`
            );

            // Show day selection buttons
            const today = new Date();
            const dayButtons = [];

            dayButtons.push([
                Markup.button.callback('Hoy', `selectDay:0:${numeroPoliza}`),
                Markup.button.callback('Ma√±ana', `selectDay:1:${numeroPoliza}`)
            ]);

            const dayNames = [
                'Domingo',
                'Lunes',
                'Martes',
                'Mi√©rcoles',
                'Jueves',
                'Viernes',
                'S√°bado'
            ];

            let nextDaysRow: any[] = [];
            for (let i = 2; i <= 6; i++) {
                const futureDate = new Date(today);
                futureDate.setDate(futureDate.getDate() + i);
                const dayName = dayNames[futureDate.getDay()];
                const dateStr = `${futureDate.getDate()}/${futureDate.getMonth() + 1}`;

                nextDaysRow.push(
                    Markup.button.callback(
                        `${dayName} ${dateStr}`,
                        `selectDay:${i}:${numeroPoliza}`
                    )
                );

                if (nextDaysRow.length === 2 || i === 6) {
                    dayButtons.push([...nextDaysRow]);
                    nextDaysRow = [];
                }
            }

            dayButtons.push([
                Markup.button.callback('‚ùå Cancelar', `cancelSelectDay:${numeroPoliza}`)
            ]);

            await ctx.reply(
                `‚úÖ Hora registrada: *${messageText}*\n\n` +
                    'üìÖ ¬øPara qu√© d√≠a programar la alerta de contacto?',
                {
                    parse_mode: 'Markdown',
                    ...Markup.inlineKeyboard(dayButtons)
                }
            );

            return true;
        } catch (error) {
            logger.error(`Error al procesar hora de contacto para p√≥liza ${numeroPoliza}:`, error);
            this.awaitingContactTime.delete(chatId, threadId);
            await ctx.reply('‚ùå Error al procesar la hora de contacto. Operaci√≥n cancelada.');
            return true;
        }
    }

    public cleanupAllStates(chatId: number, threadId: string | null = null): void {
        if (threadId) {
            this.pendingLeyendas.delete(chatId, threadId);
            this.polizaCache.delete(chatId, threadId);
            this.messageIds.delete(chatId, threadId);
            this.awaitingPhoneNumber.delete(chatId, threadId);
            this.awaitingOrigenDestino.delete(chatId, threadId);
            this.awaitingContactTime.delete(chatId, threadId);
            this.scheduledServiceInfo.delete(chatId, threadId);

            // Tambi√©n limpiar en FlowStateManager
            flowStateManager.clearAllStates(chatId, threadId);

            if (this.handler && typeof this.handler.clearChatState === 'function') {
                logger.info(
                    'Llamando a CommandHandler.clearChatState desde OcuparPolizaCallback.cleanupAllStates',
                    { chatId, threadId }
                );
                this.handler.clearChatState(chatId, threadId);
            } else {
                logger.error(
                    'No se pudo llamar a CommandHandler.clearChatState desde OcuparPolizaCallback'
                );
            }
        } else {
            this.pendingLeyendas.deleteAll(chatId);
            this.polizaCache.deleteAll(chatId);
            this.messageIds.deleteAll(chatId);
            this.awaitingPhoneNumber.deleteAll(chatId);
            this.awaitingOrigenDestino.deleteAll(chatId);
            this.awaitingContactTime.deleteAll(chatId);
            this.scheduledServiceInfo.deleteAll(chatId);

            // Tambi√©n limpiar en FlowStateManager
            flowStateManager.clearAllStates(chatId, null);

            if (this.handler && typeof this.handler.clearChatState === 'function') {
                logger.info(
                    'Llamando a CommandHandler.clearChatState desde OcuparPolizaCallback.cleanupAllStates (sin threadId)',
                    { chatId }
                );
                this.handler.clearChatState(chatId, null);
            } else {
                logger.error(
                    'No se pudo llamar a CommandHandler.clearChatState desde OcuparPolizaCallback (sin threadId)'
                );
            }
        }
    }
}

export default OcuparPolizaCallback;
